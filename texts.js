const texts = {
  "Асик": {
    "Теория": `
## 1. Инструкции и операнды. Способ записи инструкций, виды операндов, ограничения на использование операндов.

*   **Тезисно:**
    *   **Инструкция (команда):** Указание процессору, что делать (например, \`MOV\`, \`ADD\`).
    *   **Операнды:** Данные, над которыми выполняется инструкция (регистры, ячейки памяти, непосредственные значения).
    *   **Способ записи:** \`[метка:] мнемоника [операнд_назначения [, операнд_источника]]\`
        *   Пример: \`start: MOV AX, BX\`
    *   **Виды операндов:**
        1.  **Непосредственный (immediate):** Константа, число (\`MOV AX, 10\`).
        2.  **Регистровый (register):** Регистр процессора (\`MOV AX, BX\`).
        3.  **Операнд в памяти (memory):** Ячейка памяти (\`MOV AX, [myVariable]\`). Адрес может быть вычислен разными способами (прямая, косвенная, индексная адресация).
    *   **Ограничения:**
        *   **Нельзя два операнда в памяти:** \`MOV [var1], [var2]\` — запрещено. Один из операндов должен быть регистром или непосредственным значением (для \`MOV\`).
        *   **Совпадение размеров:** Операнды должны быть одинакового размера (байт с байтом, слово со словом). \`MOV AL, BX\` — ошибка.
        *   **Нельзя изменять CS:** \`MOV CS, AX\` — запрещено (только косвенно через \`JMP FAR\`, \`CALL FAR\`, \`RETF\`).
        *   **Специфичные для инструкций:** Некоторые инструкции накладывают ограничения (например, \`MUL\` берет один операнд, второй неявно \`AL\` или \`AX\`).

*   **Простое объяснение:**
    Инструкция – это глагол для процессора ("скопируй", "сложи"). Операнды – это существительные ("что" и "куда" или "что" и "с чем"). Пишем: \`ДЕЙСТВИЕ КУДА, ОТКУДА\`.
    Нельзя перекладывать вещи из одного ящика стола в другой, не взяв их сначала в руки (регистр). Размеры должны совпадать: нельзя положить большое яблоко (16 бит) в маленькую коробочку (8 бит) напрямую.

---

## 2. Регистры в архитектуре IA-32. Виды регистров, назначение.

*   **Тезисно:**
    *   **Регистры:** Сверхбыстрые ячейки памяти внутри процессора.
    *   **Виды регистров (для 8086/IA-32 базовые):**
        1.  **Регистры общего назначения (РОН, GPR):** Для хранения данных и адресов (\`AX\`, \`BX\`, \`CX\`, \`DX\`, \`SI\`, \`DI\`, \`BP\`, \`SP\`).
        2.  **Сегментные регистры:** Для управления сегментацией памяти (\`CS\`, \`DS\`, \`SS\`, \`ES\`).
        3.  **Указатель инструкций (Instruction Pointer, IP):** Хранит смещение следующей выполняемой инструкции (в паре с \`CS\`).
        4.  **Регистр флагов (FLAGS):** Хранит информацию о результате последней операции и состоянии процессора.

*   **Простое объяснение:**
    Регистры – это как маленькие, очень быстрые "блокнотики" внутри самого процессора. В них он держит самые нужные данные, чтобы не бегать каждый раз в большую "книгу" (оперативную память). Разные "блокнотики" для разных целей: одни для расчетов, другие – чтобы знать, где в "книге" искать код или данные.

---

## 3. Регистры общего назначения.

*   **Тезисно (16-битные для 8086):**
    *   **AX (Accumulator):** \`AH\` (старший байт), \`AL\` (младший байт). Основной для арифметики, ввода/вывода.
    *   **BX (Base):** \`BH\`, \`BL\`. Используется для косвенной адресации (как базовый указатель на данные).
    *   **CX (Counter):** \`CH\`, \`CL\`. Используется как счетчик в циклах (\`LOOP\`) и операциях со строками.
    *   **DX (Data):** \`DH\`, \`DL\`. Используется в операциях умножения/деления (хранит старшую часть результата/делимого), для ввода/вывода в порты.
    *   **SI (Source Index):** Индекс источника в строковых операциях. Также для косвенной адресации.
    *   **DI (Destination Index):** Индекс приемника в строковых операциях. Также для косвенной адресации.
    *   **BP (Base Pointer):** Указатель базы стекового фрейма (для доступа к параметрам и локальным переменным в стеке).
    *   **SP (Stack Pointer):** Указатель вершины стека (в паре с \`SS\`).

*   **Простое объяснение:**
    Это "рабочие лошадки" процессора:
    *   \`AX\`: Калькулятор.
    *   \`BX\`: Указка на данные в памяти.
    *   \`CX\`: Счётчик для повторений.
    *   \`DX\`: Помощник для калькулятора (для больших чисел) и для общения с внешними устройствами.
    *   \`SI\`, \`DI\`: Две указки для работы с цепочками данных (строками, массивами).
    *   \`BP\`, \`SP\`: Указки для специальной области памяти "стек" (где хранятся временные данные функций).

---

## 4. Сегментные регистры.

*   **Тезисно (16-битные для 8086):**
    *   **CS (Code Segment):** Указывает на сегмент, содержащий выполняемый код программы. Изменяется инструкциями перехода \`JMP FAR\`, \`CALL FAR\`, \`RETF\`, \`INT\`.
    *   **DS (Data Segment):** Указывает на сегмент данных по умолчанию. Большинство операций с памятью используют \`DS\` для вычисления адреса.
    *   **SS (Stack Segment):** Указывает на сегмент стека. Используется для всех стековых операций (\`PUSH\`, \`POP\`, \`CALL\`, \`RET\`).
    *   **ES (Extra Segment):** Дополнительный сегмент данных. Используется в строковых операциях (\`MOVSB\`, \`STOSB\`) для приемника, или когда нужно работать с двумя сегментами данных одновременно.

*   **Простое объяснение:**
    Память в 8086 как большая книга, разделенная на главы (сегменты) по 64 КБ. Сегментные регистры – это закладки, указывающие на начало текущей "главы" с кодом (\`CS\`), данными (\`DS\`), стеком (\`SS\`) или дополнительными данными (\`ES\`).

---

## 5. Адресация в реальном режиме. Сегмент и смещение, вычисление физического адреса.

*   **Тезисно:**
    *   **Реальный режим:** Режим работы процессора 8086 (и совместимых в этом режиме). Доступен 1 МБ памяти.
    *   **Адрес:** Задается парой \`сегмент:смещение\` (оба 16-битные).
        *   Сегмент: значение одного из сегментных регистров (\`CS\`, \`DS\`, \`SS\`, \`ES\`).
        *   Смещение (offset): 16-битное расстояние от начала сегмента.
    *   **Вычисление физического адреса (20-битного):**
        \`Физический_Адрес = (Значение_Сегментного_Регистра * 16) + Смещение\`
        (Умножение на 16 эквивалентно сдвигу влево на 4 бита или добавлению нуля справа в шестнадцатеричной системе).
        *   Пример: \`DS = 1000h\`, \`смещение = 0025h\`.
            \`Физический_Адрес = (1000h * 10h) + 0025h = 10000h + 0025h = 10025h\`.

*   **Простое объяснение:**
    Представьте карту города. Сегментный регистр говорит "улица такая-то" (например, "Ленина"). Смещение говорит "дом номер такой-то на этой улице" (например, "дом 5"). Чтобы найти точное местоположение на общей карте (физический адрес), мы берем номер улицы, умножаем на 10 (в шестнадцатеричной, или 16 в десятичной – это размер квартала), и прибавляем номер дома. Так мы получаем уникальный 20-битный адрес во всей доступной памяти (1 МБ).

---

## 6. Регистр программного счётчика (указатель инструкций).

*   **Тезисно:**
    *   **IP (Instruction Pointer):** 16-битный регистр.
    *   **Назначение:** Хранит смещение (адрес внутри сегмента кода) следующей инструкции, которая будет выполнена процессором.
    *   **Работа в паре с CS:** Полный адрес следующей инструкции: \`CS:IP\`.
    *   **Изменение:**
        *   Автоматически: увеличивается после выполнения каждой инструкции на ее длину.
        *   Принудительно: инструкциями перехода (\`JMP\`, \`CALL\`, \`RET\`), прерываниями (\`INT\`, \`IRET\`).
    *   **Недоступен для прямого изменения:** Нельзя написать \`MOV IP, 100\`.

*   **Простое объяснение:**
    \`IP\` – это как закладка в книге с инструкциями (сегмент \`CS\`), которая всегда указывает на строчку, которую процессор будет читать следующей. Прочитал строчку – передвинул закладку на следующую. Если есть команда "перейти на страницу 5, строчку 10", то \`CS\` и \`IP\` изменятся соответственно.

---

## 7. Код и данные. Генерация кода ассемблером. Выполнение кода процессором.

*   **Тезисно:**
    *   **Код:** Последовательность инструкций процессора.
    *   **Данные:** Информация, которую обрабатывает код (числа, символы, строки).
    *   **Генерация кода (трансляция):**
        1.  Программист пишет исходный код на языке ассемблера (текстовый файл, \`.asm\`).
        2.  **Ассемблер (FASM):** Программа-транслятор. Читает исходный код.
            *   Заменяет мнемоники инструкций на их машинные коды (байты).
            *   Вычисляет адреса меток и переменных.
            *   Обрабатывает директивы (команды для ассемблера, а не для процессора).
        3.  Результат: Исполняемый файл (например, \`.COM\`, \`.EXE\`) или объектный модуль (\`.OBJ\`), содержащий машинный код и данные.
    *   **Выполнение кода процессором:**
        1.  Операционная система загружает машинный код программы в оперативную память.
        2.  \`CS:IP\` устанавливаются на адрес первой инструкции программы.
        3.  Процессор циклически:
            *   Выбирает инструкцию из памяти по адресу \`CS:IP\`.
            *   Декодирует инструкцию.
            *   Выполняет инструкцию.
            *   \`IP\` обновляется для указания на следующую инструкцию.
        4.  Продолжается до инструкции завершения программы или критической ошибки.

*   **Простое объяснение:**
    *   Программист пишет "рецепт" (исходный код) на понятном ему языке (ассемблер).
    *   Ассемблер (FASM) – это "переводчик", который переводит этот "рецепт" на "язык робота" (машинный код – нули и единицы).
    *   Процессор – это "робот", который берет переведенный рецепт и шаг за шагом выполняет указания, работая с "ингредиентами" (данными).

---

## 8. Директивы ассемблера. Директивы определения данных. Объявление «массивов». Инициализированные и неинициализированные данные. Директива ORG.

*   **Тезисно:**
    *   **Директивы:** Команды для ассемблера (не для процессора). Управляют процессом сборки программы.
    *   **Директивы определения данных (инициализированные):** Выделяют память и записывают в нее начальные значения.
        *   \`DB\` (Define Byte): выделить байт(ы). \`myByte DB 10, 'A', ?\`
        *   \`DW\` (Define Word): выделить слово (2 байта). \`myWord DW 1234h, 0\`
        *   \`DD\` (Define Doubleword): выделить двойное слово (4 байта). \`myDword DD 12345678h\`
        *   \`DQ\` (Define Quadword): выделить учетверенное слово (8 байт).
        *   \`DT\` (Define Ten bytes): выделить 10 байт (для BCD).
        *   \`?\` означает, что значение не определено (но память выделяется).
    *   **Объявление «массивов»:** Через директивы определения данных или с помощью \`DUP\`.
        *   \`array DB 1, 2, 3, 4, 5\` (массив из 5 байт)
        *   \`buffer DB 100 DUP(0)\` (массив из 100 байт, заполненных нулями)
        *   \`message DB 'Hello', 0\` (строка, массив символов с нуль-терминатором)
    *   **Неинициализированные данные (резервирование):** Выделяют память, но не записывают начальные значения.
        *   \`RESB N\` (Reserve Byte): зарезервировать N байт.
        *   \`RESW N\` (Reserve Word): зарезервировать N слов.
        *   \`RESD N\` (Reserve Doubleword): зарезервировать N двойных слов.
    *   **Директива \`ORG <адрес>\` (Origin):** Устанавливает начальный адрес (смещение от начала сегмента) для последующего кода или данных. Часто используется в \`.COM\` файлах (\`ORG 100h\`).

*   **Простое объяснение:**
    *   Директивы – это записки для "переводчика" (ассемблера).
    *   \`DB\`, \`DW\`, \`DD\` – "положи сюда такие-то вещи (данные)". Массив – это просто ряд таких "вещей".
    *   \`RESB\`, \`RESW\` – "оставь здесь пустое место для вещей, их положат позже".
    *   \`ORG\` – "начинай писать/класть вещи с этого места на странице". Для \`.COM\` программ это обычно 100h, потому что первые 256 байт заняты PSP (Program Segment Prefix).

---

## 9. Инструкции пересылки. MOV и XCHG.

*   **Тезисно:**
    *   **\`MOV назначение, источник\` (Move):**
        *   Копирует данные из \`источника\` в \`назначение\`.
        *   Источник не изменяется. Старое значение в \`назначении\` теряется.
        *   Операнды должны быть одинакового размера.
        *   Нельзя \`MOV память, память\`. Один из операндов должен быть регистром, или источник может быть непосредственным значением.
        *   Примеры: \`MOV AX, BX\`, \`MOV AL, 10\`, \`MOV myVar, CX\`, \`MOV DI, [BX+SI]\`.
    *   **\`XCHG операнд1, операнд2\` (Exchange):**
        *   Обменивает содержимое двух операндов.
        *   Операнды могут быть: регистр-регистр, регистр-память.
        *   Нельзя \`XCHG память, память\`.
        *   Операнды должны быть одинакового размера.
        *   Примеры: \`XCHG AX, BX\`, \`XCHG AL, [myByte]\`.

*   **Простое объяснение:**
    *   \`MOV\` – это команда "скопируй". Как \`C = A\` в языках высокого уровня. Представьте, что вы переписываете число из одного блокнота в другой.
    *   \`XCHG\` – это команда "поменяй местами". Как \`temp = A; A = B; B = temp;\`. Представьте, что вы меняете содержимое двух стаканов.

---

## 10. Инструкции целочисленной арифметики. Целочисленные сложение, вычитание, умножение и деление. Особенности работы со знаковыми и беззнаковыми числами.

*   **Тезисно:**
    *   **Сложение:**
        *   \`ADD назначение, источник\` -> \`назначение = назначение + источник\`.
        *   \`ADC назначение, источник\` (Add with Carry) -> \`назначение = назначение + источник + CF\`. (CF – флаг переноса). Используется для многобайтной арифметики.
    *   **Вычитание:**
        *   \`SUB назначение, источник\` -> \`назначение = назначение - источник\`.
        *   \`SBB назначение, источник\` (Subtract with Borrow) -> \`назначение = назначение - источник - CF\`. (CF – флаг заема). Используется для многобайтной арифметики.
        *   \`INC назначение\` (Increment) -> \`назначение = назначение + 1\`.
        *   \`DEC назначение\` (Decrement) -> \`назначение = назначение - 1\`.
        *   \`NEG назначение\` (Negate) -> \`назначение = -назначение\` (инверсия знака, дважды дополнение).
    *   **Умножение:**
        *   \`MUL источник\` (Unsigned Multiply):
            *   Байт: \`AL * источник(байт)\` -> результат в \`AX\`.
            *   Слово: \`AX * источник(слово)\` -> результат в \`DX:AX\` (старшая часть в \`DX\`, младшая в \`AX\`).
        *   \`IMUL источник\` (Signed Multiply): То же, что и \`MUL\`, но для чисел со знаком.
    *   **Деление:**
        *   \`DIV источник\` (Unsigned Divide):
            *   Байт: \`AX / источник(байт)\` -> частное в \`AL\`, остаток в \`AH\`.
            *   Слово: \`DX:AX / источник(слово)\` -> частное в \`AX\`, остаток в \`DX\`.
        *   \`IDIV источник\` (Signed Divide): То же, что и \`DIV\`, но для чисел со знаком. (Перед делением слова на байт или двойного слова на слово может потребоваться знаковое расширение делимого: \`CBW\` или \`CWD\`).
    *   **Знаковые vs Беззнаковые:**
        *   \`ADD\`, \`SUB\` работают одинаково для знаковых и беззнаковых. Разница в интерпретации флагов (\`OF\` для знаковых, \`CF\` для беззнаковых).
        *   \`MUL\`/\`DIV\` для беззнаковых.
        *   \`IMUL\`/\`IDIV\` для знаковых.

*   **Простое объяснение:**
    *   \`ADD\`, \`SUB\` – обычные сложение и вычитание. \`INC\`/\`DEC\` – быстрый способ прибавить/отнять 1.
    *   \`MUL\`, \`IMUL\`: Умножение. Результат может быть в два раза больше, поэтому используется пара регистров (\`AX\` или \`DX:AX\`). \`MUL\` для "просто чисел", \`IMUL\` для чисел "плюс/минус".
    *   \`DIV\`, \`IDIV\`: Деление. Делимое тоже может быть большим (\`AX\` или \`DX:AX\`). Получаем частное и остаток. \`DIV\` для "просто чисел", \`IDIV\` для "плюс/минус".
    *   Числа со знаком используют старший бит для обозначения знака (0 – плюс, 1 – минус). Беззнаковые – все биты для значения.

---

## 11. Буферизация пользовательского ввода. Клавиатурный буфер, его назначение и принцип работы.

*   **Тезисно:**
    *   **Клавиатурный буфер:** Небольшая область в оперативной памяти (в BIOS Data Area, обычно начиная с \`0040:001E\`), предназначенная для временного хранения кодов нажатых клавиш.
    *   **Назначение:** Позволяет пользователю вводить данные быстрее, чем программа успевает их обработать. Предотвращает потерю нажатий.
    *   **Принцип работы:**
        1.  **Нажатие клавиши:** Генерируется аппаратное прерывание клавиатуры (\`INT 09h\`).
        2.  **Обработчик \`INT 09h\` (BIOS):**
            *   Считывает скан-код клавиши из порта клавиатуры.
            *   Преобразует скан-код в ASCII-код (если это символьная клавиша).
            *   Помещает пару (скан-код, ASCII-код) в клавиатурный буфер (кольцевой буфер).
            *   Обновляет указатели на начало и конец данных в буфере.
        3.  **Чтение программой:** Программа (например, через \`INT 16h\` или \`INT 21h\` функция \`0Ah\` в DOS) запрашивает символ из буфера.
            *   Если буфер не пуст, символ извлекается.
            *   Если буфер пуст, программа ждет, пока пользователь не нажмет клавишу.
    *   **Размер:** Обычно 15-16 символов (нажатий).

*   **Простое объяснение:**
    Клавиатурный буфер – это как маленькая "очередь" для нажатых клавиш. Когда вы быстро печатаете, а программа занята, нажатия не теряются, а складываются в эту очередь. Программа забирает их оттуда, как только освободится. Если очередь переполнится, новые нажатия могут игнорироваться (сопровождается писком).

---

## 12. Инструкции условного и безусловного перехода. JMP и Jcc.

*   **Тезисно:**
    *   **Изменяют регистр \`IP\` (и \`CS\` для дальних переходов),»  заставляя процессор выполнять код с другого адреса.**
    *   **\`JMP метка\` (Jump):** Безусловный переход. Всегда выполняется. Передает управление на инструкцию, помеченную \`меткой\`.
        *   \`SHORT\`: переход в пределах -128 до +127 байт.
        *   \`NEAR\`: переход в пределах текущего сегмента кода (64KB).
        *   \`FAR\`: переход в другой сегмент кода (изменяет \`CS\` и \`IP\`).
    *   **\`Jcc метка\` (Conditional Jump):** Условный переход. Выполняется, только если определенное условие (основанное на флагах из регистра \`FLAGS\`) истинно.
        *   \`JZ метка\` (Jump if Zero, ZF=1) / \`JE метка\` (Jump if Equal)
        *   \`JNZ метка\` (Jump if Not Zero, ZF=0) / \`JNE метка\` (Jump if Not Equal)
        *   \`JC метка\` (Jump if Carry, CF=1)
        *   \`JNC метка\` (Jump if Not Carry, CF=0)
        *   \`JS метка\` (Jump if Sign, SF=1, результат отрицательный)
        *   \`JNS метка\` (Jump if Not Sign, SF=0, результат положительный или 0)
        *   \`JO метка\` (Jump if Overflow, OF=1)
        *   \`JNO метка\` (Jump if Not Overflow, OF=0)
        *   Для знаковых сравнений (после \`CMP\`): \`JG\`/\`JNLE\`, \`JGE\`/\`JNL\`, \`JL\`/\`JNGE\`, \`JLE\`/\`JNG\`.
        *   Для беззнаковых сравнений (после \`CMP\`): \`JA\`/\`JNBE\`, \`JAE\`/\`JNB\`, \`JB\`/\`JNAE\`, \`JBE\`/\`JNA\`.
    *   Все условные переходы в 8086 являются короткими (\`SHORT\`). Для дальних условных переходов нужна комбинация: \`Jcc short_label; JMP FAR long_label; short_label: ...\`.

*   **Простое объяснение:**
    *   \`JMP\` – это как команда "Иди на страницу X, строчку Y" в книге инструкций. Всегда выполняется.
    *   \`Jcc\` – это "Если <условие выполнено>, то иди на страницу X, строчку Y, иначе продолжай читать следующую строчку". Условие проверяется по "лампочкам" (флагам), которые зажглись после предыдущей команды. Например, "Если результат был ноль (\`JZ\`), то прыгай".

---

## 13. Регистр флагов. Основные флаги и их назначение, использование регистра флагов.

*   **Тезисно:**
    *   **Регистр FLAGS (16-бит):** Содержит набор битовых флагов, отражающих состояние процессора и результаты арифметико-логических операций.
    *   **Основные флаги:**
        *   **\`CF\` (Carry Flag - Флаг переноса):**
            *   \`1\`: Был перенос из старшего бита при сложении или заем в старший бит при вычитании (для беззнаковой арифметики).
            *   \`0\`: Переноса/заема не было.
            *   Также используется в операциях сдвига/циклического сдвига.
        *   **\`ZF\` (Zero Flag - Флаг нуля):**
            *   \`1\`: Результат последней операции равен нулю.
            *   \`0\`: Результат не равен нулю.
        *   **\`SF\` (Sign Flag - Флаг знака):**
            *   \`1\`: Старший бит результата равен 1 (число отрицательное в знаковой интерпретации).
            *   \`0\`: Старший бит результата равен 0 (число положительное или ноль в знаковой интерпретации).
        *   **\`OF\` (Overflow Flag - Флаг переполнения):**
            *   \`1\`: Произошло знаковое переполнение (результат слишком большой или слишком маленький для представления в знаковом формате в данном размере операнда).
            *   \`0\`: Знакового переполнения не было.
        *   **\`PF\` (Parity Flag - Флаг четности):**
            *   \`1\`: Младший байт результата содержит четное число единичных битов.
            *   \`0\`: Младший байт результата содержит нечетное число единичных битов.
        *   **\`AF\` (Auxiliary Carry Flag - Вспомогательный флаг переноса):** Используется для BCD арифметики (перенос/заем из 3-го бита в 4-й).
        *   **\`IF\` (Interrupt Enable Flag - Флаг разрешения прерываний):**
            *   \`1\`: Маскируемые аппаратные прерывания разрешены.
            *   \`0\`: Маскируемые аппаратные прерывания запрещены (\`CLI\` устанавливает в 0, \`STI\` в 1).
        *   **\`DF\` (Direction Flag - Флаг направления):**
            *   \`0\`: Строковые операции обрабатывают память от меньших адресов к большим (\`SI\`, \`DI\` инкрементируются). Устанавливается \`CLD\`.
            *   \`1\`: Строковые операции обрабатывают память от больших адресов к меньшим (\`SI\`, \`DI\` декрементируются). Устанавливается \`STD\`.
    *   **Использование:** Главным образом для инструкций условных переходов (\`Jcc\`) и условной передачи данных (\`SETcc\`, \`CMOVcc\` - на более поздних процессорах).

*   **Простое объяснение:**
    Регистр флагов – это как приборная панель в автомобиле с лампочками. Каждая лампочка (флаг) загорается или гаснет в зависимости от того, что произошло после выполнения команды (например, "результат ноль" – загорелась \`ZF\`, "число слишком большое" – загорелась \`OF\`). Процессор смотрит на эти лампочки, чтобы решить, что делать дальше (например, при условном переходе).

---

## 14. Инструкции CMP и TEST.

*   **Тезисно:**
    *   Обе инструкции изменяют флаги, но **не изменяют** значения своих операндов. Используются для подготовки к условным переходам.
    *   **\`CMP назначение, источник\` (Compare):**
        *   Выполняет вычитание: \`назначение - источник\`.
        *   Результат вычитания никуда не сохраняется.
        *   Устанавливает флаги \`CF, ZF, SF, OF, AF, PF\` так, как если бы была выполнена инструкция \`SUB\`.
        *   Типичное использование: \`CMP AX, BX\` затем \`JE equal_label\` (если AX = BX, то ZF=1).
    *   **\`TEST назначение, источник\` (Test Logical Compare):**
        *   Выполняет побитовую операцию \`И\` (Logical AND): \`назначение AND источник\`.
        *   Результат операции никуда не сохраняется.
        *   Устанавливает флаги \`ZF, SF, PF\`.
        *   Флаги \`CF\` и \`OF\` всегда сбрасываются в 0. \`AF\` не определен.
        *   Типичное использование:
            *   \`TEST AX, AX\` затем \`JZ ax_is_zero\` (проверка, равен ли AX нулю).
            *   \`TEST AL, 01h\` затем \`JNZ bit_0_is_set\` (проверка, установлен ли младший бит в AL).

*   **Простое объяснение:**
    *   \`CMP\` – это как спросить "Равны ли X и Y?", "X больше Y?" или "X меньше Y?". Она делает вид, что вычитает, смотрит на результат, зажигает нужные "лампочки" (флаги), но сами числа X и Y не меняет.
    *   \`TEST\` – это как проверить, есть ли общие включенные "лампочки" (биты) у двух чисел, или проверить, включена ли конкретная "лампочка" (бит) в одном числе. Результат проверки тоже отражается на флагах, но числа не меняются.

---

## 15. Циклы. Организация циклов в программе на ассемблере. Инструкция LOOP.

*   **Тезисно:**
    *   **Организация цикла (общий подход):**
        1.  Инициализация счетчика/условия.
        2.  Метка начала цикла.
        3.  Тело цикла (полезная работа).
        4.  Модификация счетчика/условия.
        5.  Инструкция условного перехода на метку начала цикла (если условие продолжения выполняется).
    *   **Инструкция \`LOOP метка\`:**
        *   Автоматически выполняет:
            1.  \`DEC CX\` (уменьшает регистр \`CX\` на 1).
            2.  Если \`CX != 0\`, то переход на \`метку\`.
        *   \`CX\` должен быть предварительно инициализирован числом итераций.
        *   Если \`CX\` изначально \`0\`, цикл выполнится \`65536\` раз (для 16-битного \`CX\`). Поэтому часто перед \`LOOP\` ставят \`JCXZ skip_loop\` (Jump if CX is Zero).
    *   **Варианты \`LOOP\`:**
        *   \`LOOPE метка\` / \`LOOPZ метка\` (Loop if Equal / Loop if Zero): \`DEC CX\`, если \`CX != 0\` И \`ZF = 1\`, то переход.
        *   \`LOOPNE метка\` / \`LOOPNZ метка\` (Loop if Not Equal / Loop if Not Zero): \`DEC CX\`, если \`CX != 0\` И \`ZF = 0\`, то переход.
    *   **Цикл с помощью \`CMP\` и \`Jcc\`:** Более гибкий, не привязан к \`CX\`.
        \`\`\`assembly
          MOV CX, 10      ; Счетчик (или любой другой регистр/память)
        my_loop:
          ; Тело цикла
          DEC CX
          JNZ my_loop     ; Переход, если CX не ноль
        \`\`\`

*   **Простое объяснение:**
    Цикл – это способ заставить компьютер повторять кусок кода много раз.
    *   \`LOOP\`: "Сделай это \`CX\` раз". Перед началом в \`CX\` кладем, сколько раз надо повторить. \`LOOP\` сама отсчитывает и прыгает назад.
    *   Общий способ: Ставим "закладку" (метку). Делаем работу. Проверяем условие (например, "счетчик еще не дошел до нуля?"). Если да – прыгаем на "закладку".

---

## 16. Инструкции побитовых сдвигов.

*   **Тезисно:**
    *   Сдвигают биты в операнде (регистре или памяти) влево или вправо.
    *   Второй операнд: число сдвигов (1 или значение регистра \`CL\`).
    *   **Логические сдвиги:**
        *   \`SHL назначение, счетчик\` (Shift Logical Left): Сдвиг влево. Крайний левый бит уходит в \`CF\`. Правый бит заполняется нулем. \`SAL\` (Shift Arithmetic Left) – идентична \`SHL\`.
        *   \`SHR назначение, счетчик\` (Shift Logical Right): Сдвиг вправо. Крайний правый бит уходит в \`CF\`. Левый бит заполняется нулем.
    *   **Арифметический сдвиг (вправо):**
        *   \`SAR назначение, счетчик\` (Shift Arithmetic Right): Сдвиг вправо. Крайний правый бит уходит в \`CF\`. Левый бит (знаковый) копируется (сохраняется знак числа).
    *   **Циклические сдвиги (без флага переноса):**
        *   \`ROL назначение, счетчик\` (Rotate Left): Сдвиг влево. Крайний левый бит уходит в \`CF\` И на место правого бита.
        *   \`ROR назначение, счетчик\` (Rotate Right): Сдвиг вправо. Крайний правый бит уходит в \`CF\` И на место левого бита.
    *   **Циклические сдвиги (через флаг переноса):**
        *   \`RCL назначение, счетчик\` (Rotate through Carry Left): Сдвиг влево. Крайний левый бит уходит в \`CF\`. Значение из \`CF\` уходит на место правого бита.
        *   \`RCR назначение, счетчик\` (Rotate through Carry Right): Сдвиг вправо. Крайний правый бит уходит в \`CF\`. Значение из \`CF\` уходит на место левого бита.
    *   **Применение:** Быстрое умножение/деление на степени 2, работа с отдельными битами, упаковка/распаковка данных.

*   **Простое объяснение:**
    Представьте ряд лампочек (биты). Сдвиги – это как передвижение всех лампочек на одну позицию влево или вправо.
    *   \`SHL\`/\`SAL\` (влево): Лампочки двигаются влево, самая левая выпадает (и ее состояние запоминается во флаге \`CF\`), справа загорается новая (всегда выключенная). Умножение на 2.
    *   \`SHR\` (вправо, логический): Лампочки вправо, правая выпадает (в \`CF\`), слева загорается выключенная. Беззнаковое деление на 2.
    *   \`SAR\` (вправо, арифметический): Так же, но слева загорается такая же, какая была самая левая до сдвига (чтобы сохранить знак числа). Знаковое деление на 2.
    *   \`ROL\`/\`ROR\`: Лампочка, которая "выпала" с одного конца, "загорается" на другом.
    *   \`RCL\`/\`RCR\`: То же, но лампочка проходит через "промежуточную станцию" – флаг \`CF\`.

---

## 17. Инструкции преобразования типов. Инструкции MOVZX и MOVSX. Инструкции CBW и CWD.

*   **Тезисно:**
    *   Используются для преобразования данных из одного размера в другой (например, байт в слово).
    *   **\`MOVZX назначение_больше, источник_меньше\` (Move with Zero Extend):** (Доступна с 80386 процессора)
        *   Копирует \`источник_меньше\` в \`назначение_больше\`.
        *   Старшие биты \`назначения\` заполняются нулями.
        *   Используется для беззнакового расширения. \`MOVZX AX, BL\`.
    *   **\`MOVSX назначение_больше, источник_меньше\` (Move with Sign Extend):** (Доступна с 80386 процессора)
        *   Копирует \`источник_меньше\` в \`назначение_больше\`.
        *   Старшие биты \`назначения\` заполняются значением знакового бита \`источника\`.
        *   Используется для знакового расширения. \`MOVSX AX, BL\`.
    *   **\`CBW\` (Convert Byte to Word):** (Доступна на 8086)
        *   Преобразует знаковый байт в \`AL\` в знаковое слово в \`AX\`.
        *   Если старший бит \`AL\` (знаковый) равен 0, \`AH\` заполняется \`00h\`.
        *   Если старший бит \`AL\` равен 1, \`AH\` заполняется \`FFh\`.
    *   **\`CWD\` (Convert Word to Double Word):** (Доступна на 8086)
        *   Преобразует знаковое слово в \`AX\` в знаковое двойное слово в \`DX:AX\`.
        *   Если старший бит \`AX\` (знаковый) равен 0, \`DX\` заполняется \`0000h\`.
        *   Если старший бит \`AX\` равен 1, \`DX\` заполняется \`FFFFh\`.
        *   Часто используется перед \`IDIV\` для подготовки делимого.

*   **Простое объяснение:**
    Иногда маленькое число нужно "растянуть" до большого размера.
    *   *Для 8086:*
        *   \`CBW\`: Если в \`AL\` лежит число (например, 5 или -5), \`CBW\` "растягивает" его до \`AX\`, сохраняя знак.
        *   \`CWD\`: То же самое, но из \`AX\` в \`DX:AX\`. Нужно для деления больших чисел со знаком.
    *   *Если бы был 386+ (для общего понимания):*
        *   \`MOVZX\`: Взять маленькое число и добавить нули спереди, чтобы оно стало большим (например, байт \`11111111b\` (255) станет словом \`00000000_11111111b\` (255)).
        *   \`MOVSX\`: Взять маленькое число со знаком и добавить спереди копии его знакового бита (например, байт \`11111111b\` (-1) станет словом \`11111111_11111111b\` (-1)).

---

## 18. Стек. Инструкции для работы со стеком.

*   **Тезисно:**
    *   **Стек:** Область памяти, организованная по принципу **LIFO** (Last-In, First-Out – "последним пришел, первым ушел").
    *   **Указатель стека:** \`SS:SP\`. \`SS\` – сегмент стека, \`SP\` (Stack Pointer) – смещение вершины стека.
    *   **Рост стека:** В архитектуре x86 стек растет вниз (от старших адресов к младшим). При добавлении элемента \`SP\` уменьшается.
    *   **Основные инструкции:**
        *   **\`PUSH источник\` (Push onto Stack):**
            1.  \`SP = SP - 2\` (для 16-битных операндов).
            2.  Копирует значение \`источника\` (регистр или память 16 бит) в ячейку \`SS:[SP]\`.
        *   **\`POP назначение\` (Pop from Stack):**
            1.  Копирует значение из \`SS:[SP]\` в \`назначение\` (регистр или память 16 бит).
            2.  \`SP = SP + 2\`.
        *   **\`PUSHF\`:** Помещает регистр флагов \`FLAGS\` в стек.
        *   **\`POPF\`:** Извлекает значение из стека в регистр \`FLAGS\`.
        *   \`(80186+) PUSHA\` (Push All): Помещает все регистры общего назначения (AX, CX, DX, BX, SP(старое), BP, SI, DI) в стек.
        *   \`(80186+) POPA\` (Pop All): Извлекает в обратном порядке.
    *   **Использование:** Временное хранение данных, передача параметров в процедуры, сохранение адресов возврата при вызове процедур (\`CALL\`) и прерываний (\`INT\`).

*   **Простое объяснение:**
    Стек – это как стопка тарелок.
    *   \`PUSH\`: Положить тарелку (данные) сверху на стопку. \`SP\` (указатель на верх стопки) сдвигается "ниже" (адрес уменьшается).
    *   \`POP\`: Взять верхнюю тарелку из стопки. \`SP\` сдвигается "выше" (адрес увеличивается).
    Используется, чтобы временно что-то сохранить, передать "записку" (параметр) в функцию или запомнить, куда вернуться после выполнения функции.

---

## 19. Процедуры. Инструкции для организации процедур. Ближний и дальний вызов. Способы передачи параметров.

*   **Тезисно:**
    *   **Процедура (подпрограмма, функция, subroutine):** Именованный блок кода, который можно вызывать из разных мест программы.
    *   **Инструкции для процедур:**
        *   **\`CALL метка_процедуры\` (Call Procedure):**
            1.  Помещает адрес следующей за \`CALL\` инструкции (адрес возврата) в стек.
                *   \`NEAR CALL\`: В стек кладется \`IP\` (2 байта). Процедура в том же сегменте кода.
                *   \`FAR CALL\`: В стек кладется \`CS\`, затем \`IP\` (4 байта). Процедура может быть в другом сегменте кода.
            2.  Передает управление на \`метку_процедуры\` (загружает новый \`IP\`, а для \`FAR\` и \`CS\`).
        *   **\`RET [число]\` (Return from Procedure):**
            1.  Извлекает адрес возврата из стека в \`IP\` (и \`CS\` для \`FAR RET\` - \`RETF\`).
            2.  \`[число]\` (опционально): Дополнительно прибавляет \`число\` к \`SP\` после извлечения адреса возврата. Используется для очистки параметров, переданных в процедуру через стек (характерно для \`stdcall\`, \`pascal\`).
    *   **Определение процедуры:**
        \`\`\`assembly
        имя_процедуры PROC [NEAR|FAR]
            ; тело процедуры
            RET [число] ; или RETF [число]
        имя_процедуры ENDP
        \`\`\`
        \`NEAR\` по умолчанию, если не указано.
    *   **Способы передачи параметров:**
        1.  **Через регистры:** Самый быстрый способ для небольшого числа параметров. (Например, \`MOV AX, param1\`, \`CALL MyProc\`).
        2.  **Через стек:** Параметры помещаются в стек (\`PUSH\`) перед \`CALL\`. Процедура читает их из стека (обычно используя \`BP\`).
        3.  **Через общие переменные (глобальные):** Данные записываются в заранее определенные ячейки памяти. Не рекомендуется для общего случая (ухудшает модульность).
        4.  **Смешанный:** Комбинация вышеперечисленных.

*   **Простое объяснение:**
    Процедура – это как отдельный маленький "рецепт" для выполнения какой-то задачи (например, "напечатать символ").
    *   \`CALL\`: "Иди выполни рецепт 'напечатать символ'. Запомни, где остановился здесь, чтобы потом вернуться". Адрес возврата кладется в стопку-стек.
    *   \`RET\`: "Я закончил рецепт, возвращаюсь туда, откуда меня позвали". Берет адрес возврата из стопки-стека.
    *   Ближний вызов – в той же "главе книги" (сегменте). Дальний – возможно, в другой "главе".
    *   Передать параметры – это как дать "ингредиенты" для рецепта: можно положить в "карман" (регистр) или на "поднос" (стек).

---

## 20. Соглашения вызова. Соглашение вызова MS-DOS. Соглашения pascal, ccall, stdcall и др.

*   **Тезисно:**
    *   **Соглашение о вызовах (Calling Convention):** Набор правил о том, как передаются параметры в процедуру, как возвращается результат, и кто отвечает за очистку стека от параметров. Важно для взаимодействия модулей, написанных на разных языках или разными компиляторами.
    *   **MS-DOS (через \`INT 21h\`):**
        *   **Параметры:** В регистрах. Номер функции в \`AH\` (иногда \`AL\`). Остальные параметры в \`BX\`, \`CX\`, \`DX\`, \`SI\`, \`DI\`, \`DS:DX\` и т.д., в зависимости от конкретной функции.
        *   **Возврат значения:** В регистрах (\`AL\`, \`AX\`, \`DX:AX\`). Флаг \`CF\` часто используется для индикации ошибки (\`CF=1\` - ошибка, \`CF=0\` - успех, код ошибки в \`AX\`).
        *   **Очистка стека:** Не используется стек для передачи параметров для большинства функций \`INT 21h\`, поэтому вопрос очистки не стоит.
        *   **Сохранение регистров:** Вызываемая функция DOS может изменять \`AX\`, \`BX\`, \`CX\`, \`DX\`, флаги. Остальные (сегментные, \`SI\`, \`DI\`, \`BP\`, \`SP\`) обычно сохраняются, если это не функция, которая их специфично меняет (например, установка сегментного регистра).
    *   **\`cdecl\` (C Declaration):**
        *   Параметры передаются в стек справа налево.
        *   **Вызывающая сторона (caller) очищает стек.**
        *   Возврат значения обычно в \`AX\` (или \`DX:AX\`).
        *   Позволяет использовать переменное число аргументов (например, \`printf\`).
    *   **\`stdcall\` (Standard Call):**
        *   Параметры передаются в стек справа налево.
        *   **Вызываемая процедура (callee) очищает стек** (используя \`RET N\`).
        *   Возврат значения обычно в \`AX\`.
        *   Не поддерживает переменное число аргументов. Широко используется в WinAPI.
    *   **\`pascal\`:**
        *   Параметры передаются в стек слева направо.
        *   **Вызываемая процедура (callee) очищает стек.**
        *   Возврат значения обычно в \`AX\`.
    *   FASM позволяет гибко управлять этим. Для внутренних процедур можно использовать своё соглашение. При вызове внешних (например, API) нужно соблюдать их соглашение.

*   **Простое объяснение:**
    Соглашение о вызовах – это "правила этикета" при общении между разными частями программы или с операционной системой.
    *   Кто кладет "ингредиенты" (параметры) на "поднос" (стек) и в каком порядке?
    *   Кто убирает "поднос" после использования?
    *   Где искать результат работы?
    Например, для MS-DOS: "номер услуги скажи в \`AH\`, данные дай в \`DX\`, результат заберешь в \`AX\`". Для \`cdecl\`: "положи параметры на поднос справа налево, я сам уберу". Для \`stdcall\`: "положи параметры на поднос справа налево, я уберу за собой".

---

## 21. Стековый фрейм. Пролог и эпилог. Выделение памяти для локальных переменных.

*   **Тезисно:**
    *   **Стековый фрейм (Stack Frame, Activation Record):** Область в стеке, выделяемая для одного вызова процедуры. Содержит параметры, адрес возврата, сохраненные значения регистров (особенно \`BP\`) и место для локальных переменных процедуры.
    *   **Регистр \`BP\` (Base Pointer):** Используется как указатель базы текущего стекового фрейма. Доступ к параметрам и локальным переменным осуществляется через смещения относительно \`BP\`.
    *   **Пролог процедуры (стандартный):** Код в начале процедуры для создания стекового фрейма.
        1.  \`PUSH BP\` ; Сохранить старое значение \`BP\` (базу фрейма вызвавшей процедуры).
        2.  \`MOV BP, SP\` ; \`BP\` теперь указывает на вершину стека (новую базу фрейма). Адрес возврата находится по \`[BP+2]\` (для \`NEAR\`), параметры \`[BP+4]\`, \`[BP+6]\` и т.д.
        3.  \`SUB SP, N\` ; Выделить \`N\` байт в стеке для локальных переменных (локальные переменные будут доступны по \`[BP-2]\`, \`[BP-4]\` и т.д.).
    *   **Эпилог процедуры (стандартный):** Код в конце процедуры для уничтожения стекового фрейма и возврата управления.
        1.  \`MOV SP, BP\` ; Освободить память, выделенную под локальные переменные (указатель стека \`SP\` возвращается к сохраненному \`BP\`).
        2.  \`POP BP\` ; Восстановить старое значение \`BP\`.
        3.  \`RET [размер_параметров]\` ; Вернуться и (если нужно) очистить параметры со стека.
    *   **Локальные переменные:** Размещаются в стековом фрейме, доступны по отрицательным смещениям от \`BP\`. Существуют только во время выполнения процедуры.

*   **Простое объяснение:**
    Каждый раз, когда вызывается процедура, она получает свой "рабочий стол" на общей "стопке тарелок" (стеке). Этот "рабочий стол" называется стековым фреймом.
    *   **Пролог** (входя в кабинет):
        1.  "Запомнить, где был старый стол" (\`PUSH BP\`).
        2.  "Поставить свой стол наверх" (\`MOV BP, SP\`). Теперь \`BP\` – это наш стол.
        3.  "Освободить место на столе для своих бумаг" (локальных переменных) (\`SUB SP, N\`).
    *   Теперь параметры, которые передали, лежат "под столом" (положительные смещения от \`BP\`), а "свои бумаги" – на столе (отрицательные смещения от \`BP\`).
    *   **Эпилог** (выходя из кабинета):
        1.  "Убрать свои бумаги со стола" (\`MOV SP, BP\`).
        2.  "Вернуть старый стол на место" (\`POP BP\`).
        3.  "Уйти" (\`RET\`).

---

## 22. Прерывания. Таблица векторов прерываний. Обработка прерываний: вызов обработчика и возврат из него. Перехват прерываний. Требования к обработчикам прерываний.

*   **Тезисно:**
    *   **Прерывание:** Механизм, позволяющий процессору приостановить выполнение текущей программы для обработки какого-либо события (аппаратного или программного), а затем вернуться к прерванной программе.
    *   **Типы:**
        *   **Аппаратные:** От внешних устройств (клавиатура, таймер, диск).
        *   **Программные:** Вызываются инструкцией \`INT N\` (где N - номер прерывания от 0 до 255). Используются для вызова функций ОС (например, \`INT 21h\` в MS-DOS) или BIOS (\`INT 10h\` - видео, \`INT 16h\` - клавиатура).
        *   **Исключения:** Генерируются процессором при ошибках (деление на ноль, неверный опкод).
    *   **Таблица векторов прерываний (IVT - Interrupt Vector Table):**
        *   В реальном режиме находится в самом начале памяти, с адреса \`0000:0000\`.
        *   Размер 1024 байта (256 векторов * 4 байта/вектор).
        *   Каждый вектор – это 4-байтовый \`FAR\` адрес (смещение \`IP\`, затем сегмент \`CS\`) обработчика соответствующего прерывания. Вектор для \`INT N\` находится по адресу \`N*4\`.
    *   **Обработка прерывания (действие инструкции \`INT N\` или аппаратного сигнала):**
        1.  \`PUSHF\` (сохранить регистр флагов в стек).
        2.  \`CLI\` (сбросить флаг \`IF\` - запретить другие маскируемые прерывания). (Для аппаратных прерываний и исключений. \`INT N\` сама по себе не всегда очищает \`IF\`, но обработчик обычно работает с \`IF=0\`).
        3.  \`PUSH CS\` (сохранить текущий сегмент кода).
        4.  \`PUSH IP\` (сохранить текущий указатель инструкции).
        5.  Загрузить новый \`CS:IP\` из IVT по адресу \`N*4\`. Начинается выполнение обработчика.
    *   **Возврат из обработчика:** Инструкция \`IRET\` (Interrupt Return).
        1.  \`POP IP\`
        2.  \`POP CS\`
        3.  \`POPF\`
    *   **Перехват прерываний:** Замена адреса обработчика в IVT на адрес своей собственной процедуры-обработчика. Часто свой обработчик сначала выполняет какие-то действия, а затем вызывает старый обработчик (адрес которого предварительно сохранили).
    *   **Требования к обработчикам прерываний:**
        *   Должны быть максимально быстрыми.
        *   **Обязаны сохранять и восстанавливать все регистры, которые они изменяют** (кроме тех, через которые возвращается результат, если это предусмотрено). Обычно \`PUSHA\`/\`POPA\` (на 186+).
        *   Завершаться инструкцией \`IRET\`.
        *   Если обработчик разрешает прерывания (\`STI\`), он должен быть реентерабельным (т.е. способным корректно работать, если его вызовут снова до завершения предыдущего вызова).

*   **Простое объяснение:**
    Прерывание – это как телефонный звонок. Вы заняты своими делами (программа), но тут звонок (прерывание).
    *   Процессор: "Ой, звонок! Запомню, на чем я остановился (адрес, флаги) и положу трубку (\`PUSHF\`, \`PUSH CS\`, \`PUSH IP\`). Посмотрю в справочник (IVT), кто отвечает на этот тип звонка, и передам ему трубку (загрузка \`CS:IP\` обработчика)".
    *   Обработчик (тот, кто взял трубку) быстро делает свое дело. Перед этим он должен свои "рабочие инструменты" (регистры), которые он будет использовать, отложить в сторону (\`PUSH AX\` и т.д.), а после работы вернуть на место (\`POP AX\`).
    *   Закончив, обработчик говорит "Я всё!" и кладет трубку (\`IRET\`). Процессор возвращается к тому, на чем остановился.
    *   Перехват – это когда вы ставите переадресацию: "Если звонок типа X, сначала соедините со мной, а потом я, если надо, соединю с тем, кто отвечал раньше".

---

## 23. Строковые данные и массивы. Способы представления в памяти, примеры. Инструкции обработки строк и массивов.

*   **Тезисно:**
    *   **Массивы:** Последовательность однотипных элементов в памяти.
        *   \`myArray DB 10, 20, 30\` (массив байт)
        *   \`wordArray DW 1000h, 2000h\` (массив слов)
        *   Доступ к элементам: \`MOV AL, [myArray+1]\` (второй элемент), или через индексные регистры \`MOV AL, [SI]\`, \`MOV AL, [BX+SI]\`.
    *   **Строковые данные:** Частный случай массива байт (или слов для Unicode, но не актуально для 8086).
        *   **ASCIIZ-строка (C-строка):** Заканчивается нулевым байтом (байт со значением 0).
            \`message DB 'Hello, world!', 0\`
        *   **Pascal-строка (L-string, Length-prefixed):** Первый байт хранит длину строки (до 255 символов).
            \`pascalStr DB 5, 'Hello'\`
    *   **Инструкции обработки строк:**
        *   Используют регистры \`SI\` (Source Index, источник, обычно \`DS:SI\`) и \`DI\` (Destination Index, приемник, обычно \`ES:DI\`). \`CX\` как счетчик. Флаг \`DF\` (Direction Flag) определяет направление: \`DF=0\` (\`CLD\`) – инкремент \`SI\`/\`DI\`, \`DF=1\` (\`STD\`) – декремент \`SI\`/\`DI\`.
        *   **\`MOVSB/MOVSW\` (Move String Byte/Word):** Копирует байт/слово из \`[SI]\` в \`[DI]\`. \`SI\` и \`DI\` изменяются.
        *   **\`CMPSB/CMPSW\` (Compare String Byte/Word):** Сравнивает байт/слово из \`[SI]\` с \`[DI]\`. Устанавливает флаги. \`SI\` и \`DI\` изменяются.
        *   **\`SCASB/SCASW\` (Scan String Byte/Word):** Сравнивает \`AL\`/\`AX\` с байтом/словом в \`[DI]\`. Устанавливает флаги. \`DI\` изменяется.
        *   **\`LODSB/LODSW\` (Load String Byte/Word):** Загружает байт/слово из \`[SI]\` в \`AL\`/\`AX\`. \`SI\` изменяется.
        *   **\`STOSB/STOSW\` (Store String Byte/Word):** Сохраняет \`AL\`/\`AX\` в \`[DI]\`. \`DI\` изменяется.
        *   **Префиксы повторения (ставятся перед строковой инструкцией):**
            *   \`REP\`: Повторять инструкцию \`CX\` раз. \`CX\` уменьшается на каждой итерации. (Для \`MOVS\`, \`LODS\`, \`STOS\`).
            *   \`REPE\`/\`REPZ\` (Repeat if Equal/Zero): Повторять, пока \`CX != 0\` И \`ZF = 1\`. (Для \`CMPS\`, \`SCAS\`).
            *   \`REPNE\`/\`REPNZ\` (Repeat if Not Equal/Not Zero): Повторять, пока \`CX != 0\` И \`ZF = 0\`. (Для \`CMPS\`, \`SCAS\`).

*   **Простое объяснение:**
    *   Массив – это как ряд ячеек, где лежат одинаковые по типу вещи (байты, слова).
    *   Строка – это массив букв. Чтобы знать, где строка кончается, либо ставят специальный знак в конце (ноль, как в C), либо в начале пишут ее длину (как в Pascal).
    *   Процессор имеет специальные быстрые команды для работы с целыми рядами таких данных:
        *   \`MOVSB/W\`: "Скопируй целый ряд ячеек отсюда (\`SI\`) туда (\`DI\`)".
        *   \`CMPSB/W\`: "Сравни два ряда ячеек".
        *   \`SCASB/W\`: "Найди в ряду ячеек (\`DI\`) такую же, как у меня в руке (\`AL\`/\`AX\`)".
        *   \`LODSB/W\`: "Возьми следующую ячейку из ряда (\`SI\`) себе в руку (\`AL\`/\`AX\`)".
        *   \`STOSB/W\`: "Положи то, что у меня в руке (\`AL\`/\`AX\`), в следующую ячейку ряда (\`DI\`)".
    *   Префиксы \`REP\` – это как "Повтори эту команду \`CX\` раз" или "Повторяй, пока не найдешь нужное или пока не кончатся \`CX\` попыток". \`DF\` говорит, в какую сторону двигаться по ряду: вперед или назад.

---

## 24. Работа с видеопамятью. Основные принципы. Понятие видеорежима. Форматы видеопамяти. Основы построения анимации.

*   **Тезисно:**
    *   **Основные принципы:** Изображение на экране формируется видеоадаптером, который читает данные из специальной области ОЗУ – видеопамяти. Программа может напрямую изменять содержимое этой памяти, чтобы менять изображение.
    *   **Видеорежим:** Конфигурация видеоадаптера, определяющая:
        *   Разрешение экрана (например, 80x25 символов, 320x200 пикселей).
        *   Количество доступных цветов.
        *   Способ организации данных в видеопамяти (текстовый или графический).
        *   Устанавливается через BIOS \`INT 10h, AH=00h, AL=номер_режима\`.
    *   **Форматы видеопамяти (примеры для стандартных режимов):**
        *   **Текстовый режим (например, режим \`03h\`: 80x25 символов, 16 цветов):**
            *   Видеопамять обычно начинается с адреса \`B800:0000\` (для цветных адаптеров CGA/EGA/VGA).
            *   Каждый символ на экране представлен двумя байтами:
                1.  Байт 1: ASCII-код символа.
                2.  Байт 2: Байт атрибутов (Цвет символа | Цвет фона).
                    *   Младшие 4 бита: цвет символа (0-15).
                    *   Старшие 3 бита: цвет фона (0-7).
                    *   Самый старший бит (бит 7): мерцание (1-мерцает, 0-нет).
            *   Адрес символа в строке \`R\` и колонке \`C\` (нумерация с 0): \`B800: (R * 80 + C) * 2\`.
        *   **Графический режим (например, режим \`13h\` VGA: 320x200 пикселей, 256 цветов):**
            *   Видеопамять обычно начинается с адреса \`A000:0000\`.
            *   Каждый байт в видеопамяти соответствует одному пикселю на экране. Значение байта (0-255) – это индекс цвета в палитре.
            *   Адрес пикселя с координатами \`(X, Y)\`: \`A000: (Y * 320 + X)\`.
    *   **Основы построения анимации (простейший случай):**
        1.  **Очистка кадра/области:** Заполнить старое положение объекта цветом фона.
        2.  **Отрисовка объекта:** Записать данные нового положения объекта в видеопамять.
        3.  **Пауза:** Небольшая задержка для восприятия кадра.
        4.  **Повтор:** Перейти к шагу 1 для следующего кадра анимации.
        *   Для плавной анимации в графических режимах часто используется **двойная буферизация**: отрисовка происходит в скрытом буфере в ОЗУ, а затем готовый кадр быстро копируется в видеопамять. Это предотвращает мерцание.

*   **Простое объяснение:**
    *   Экран – это "окно", показывающее содержимое специальной "доски" (видеопамяти). Что на "доске" нарисуешь, то в "окне" и увидишь.
    *   Видеорежим – это как выбрать размер "доски" (80x25 букв или 320x200 точек) и сколько "мелков" (цветов) у тебя есть.
    *   В **текстовом режиме** на "доске" для каждой буквы есть две ячейки: одна для самой буквы, другая – для ее цвета и цвета фона.
    *   В **графическом режиме** (например, VGA 320x200), каждая ячейка на "доске" – это одна точка, а число в ячейке – ее цвет.
    *   **Анимация** – это как мультфильм:
        1.  Нарисуй человечка.
        2.  Подожди чуть-чуть.
        3.  Сотри человечка (нарисуй на его месте фон).
        4.  Нарисуй человечка чуть-чуть в другом месте.
        5.  Повторяй быстро.
    *   Чтобы не было "мигания", рисуют на "запасной доске", а потом быстро меняют ее местами с той, что видна в "окне".

`,
    "Инструкции": `
# 1. Инструкции пересылки данных

## \`MOV\` (Move)
*   **Тезисно:** Копирует данные из источника в приемник. \`MOV приемник, источник\`.

## \`XCHG\` (Exchange)
*   **Тезисно:** Обменивает содержимое двух операндов (регистр-регистр или регистр-память). \`XCHG операнд1, операнд2\`.

## \`PUSH\` (Push onto Stack)
*   **Тезисно:** Уменьшает указатель стека \`SP\` и помещает значение 16-битного операнда в стек. \`PUSH источник\`.

## \`PUSHA\` (Push All General Registers)
*   **Тезисно:** (80186+) Помещает все 8 16-битных регистров общего назначения (AX, CX, DX, BX, SP(старое), BP, SI, DI) в стек.

## \`PUSHF\` (Push Flags)
*   **Тезисно:** Помещает 16-битный регистр флагов \`FLAGS\` в стек.

## \`POP\` (Pop from Stack)
*   **Тезисно:** Копирует 16-битное значение с вершины стека в операнд и увеличивает указатель стека \`SP\`. \`POP приемник\`.

## \`POPA\` (Pop All General Registers)
*   **Тезисно:** (80186+) Извлекает значения для 8 16-битных регистров общего назначения из стека в обратном порядке \`PUSHA\`. SP не загружается, а пропускается.

## \`POPF\` (Pop Flags)
*   **Тезисно:** Извлекает 16-битное значение из стека в регистр флагов \`FLAGS\`.

## \`LEA\` (Load Effective Address)
*   **Тезисно:** Загружает вычисленный адрес (смещение) операнда из памяти в 16-битный регистр. \`LEA регистр, [выражение_адреса]\`. Не обращается к памяти для чтения самих данных, только вычисляет их адрес.

## \`MOVZX\` (Move with Zero Extend)
*   **Тезисно:** (80386+) Копирует меньший операнд (8 или 16 бит) в больший (16 или 32 бит), расширяя старшие биты нулями (для беззнаковых чисел). \`MOVZX приемник_больший, источник_меньший\`.

## \`MOVSX\` (Move with Sign Extend)
*   **Тезисно:** (80386+) Копирует меньший операнд (8 или 16 бит) в больший (16 или 32 бит), расширяя старшие биты знаковым битом источника (для знаковых чисел). \`MOVSX приемник_больший, источник_меньший\`.

## \`CBW\` (Convert Byte to Word)
*   **Тезисно:** Расширяет знаковый байт в регистре \`AL\` до знакового слова в регистре \`AX\` путем копирования знакового бита \`AL\` во все биты \`AH\`.

## \`CWD\` (Convert Word to Double Word)
*   **Тезисно:** Расширяет знаковое слово в регистре \`AX\` до знакового двойного слова в паре регистров \`DX:AX\` путем копирования знакового бита \`AX\` во все биты \`DX\`. Используется перед \`IDIV\` со словом.

# 2. Инструкции арифметики

## \`ADD\` (Add)
*   **Тезисно:** Складывает источник с приемником, результат помещается в приемник. \`ADD приемник, источник\`. Устанавливает флаги \`CF, ZF, SF, OF, PF, AF\`.

## \`ADC\` (Add with Carry)
*   **Тезисно:** Складывает источник, приемник и флаг переноса (\`CF\`), результат помещается в приемник. \`ADC приемник, источник\`. Используется для многобайтной арифметики.

## \`SUB\` (Subtract)
*   **Тезисно:** Вычитает источник из приемника, результат помещается в приемник. \`SUB приемник, источник\`. Устанавливает флаги \`CF, ZF, SF, OF, PF, AF\`.

## \`SBB\` (Subtract with Borrow)
*   **Тезисно:** Вычитает источник и флаг переноса/заема (\`CF\`) из приемника, результат помещается в приемник. \`SBB приемник, источник\`. Используется для многобайтной арифметики.

## \`INC\` (Increment)
*   **Тезисно:** Увеличивает операнд на 1. \`INC операнд\`. Устанавливает \`ZF, SF, OF, PF, AF\`, не влияет на \`CF\`.

## \`DEC\` (Decrement)
*   **Тезисно:** Уменьшает операнд на 1. \`DEC операнд\`. Устанавливает \`ZF, SF, OF, PF, AF\`, не влияет на \`CF\`.

## \`MUL\` (Unsigned Multiply)
*   **Тезисно:** Беззнаковое умножение.
    *   Байт: \`AL * источник(8-бит)\` -> результат в \`AX\`.
    *   Слово: \`AX * источник(16-бит)\` -> результат в \`DX:AX\` (старшая часть в \`DX\`).
    \`MUL источник\`. Устанавливает \`CF\` и \`OF\` если старшая часть результата не ноль.

## \`IMUL\` (Signed Multiply)
*   **Тезисно:** Знаковое умножение.
    *   Байт: \`AL * источник(8-бит)\` -> результат в \`AX\`.
    *   Слово: \`AX * источник(16-бит)\` -> результат в \`DX:AX\` (старшая часть в \`DX\`).
    \`IMUL источник\`. Устанавливает \`CF\` и \`OF\` если старшая часть результата не является знаковым расширением младшей. (Для 8086 есть только однооперандная форма. Более поздние процессоры имеют 2-х и 3-х операндные формы).

## \`DIV\` (Unsigned Divide)
*   **Тезисно:** Беззнаковое деление.
    *   Слово на Байт: \`AX / источник(8-бит)\` -> частное в \`AL\`, остаток в \`AH\`.
    *   Двойное слово на Слово: \`DX:AX / источник(16-бит)\` -> частное в \`AX\`, остаток в \`DX\`.
    \`DIV источник\`. Флаги не определены. Ошибка при делении на ноль или если частное не помещается.

## \`IDIV\` (Signed Divide)
*   **Тезисно:** Знаковое деление.
    *   Слово на Байт: \`AX / источник(8-бит)\` -> частное в \`AL\`, остаток в \`AH\`. (Перед этим обычно \`CBW\`).
    *   Двойное слово на Слово: \`DX:AX / источник(16-бит)\` -> частное в \`AX\`, остаток в \`DX\`. (Перед этим обычно \`CWD\`).
    \`IDIV источник\`. Флаги не определены. Ошибка при делении на ноль или если частное не помещается.

## \`NEG\` (Negate)
*   **Тезисно:** Инвертирует знак операнда (вычисляет дважды дополнение: \`0 - опе란드\`). \`NEG операнд\`. Устанавливает флаги как \`SUB\` от нуля. \`CF=1\` если операнд не 0.

# 3. Логические и побитовые инструкции

## \`AND\` (Logical AND)
*   **Тезисно:** Выполняет побитовую операцию "И" между источником и приемником, результат в приемнике. \`AND приемник, источник\`. \`CF=0, OF=0\`. Устанавливает \`SF, ZF, PF\`.

## \`OR\` (Logical Inclusive OR)
*   **Тезисно:** Выполняет побитовую операцию "ИЛИ" между источником и приемником, результат в приемнике. \`OR приемник, источник\`. \`CF=0, OF=0\`. Устанавливает \`SF, ZF, PF\`.

## \`XOR\` (Logical Exclusive OR)
*   **Тезисно:** Выполняет побитовую операцию "исключающее ИЛИ" между источником и приемником, результат в приемнике. \`XOR приемник, источник\`. \`CF=0, OF=0\`. Устанавливает \`SF, ZF, PF\`.

## \`NOT\` (Logical NOT)
*   **Тезисно:** Инвертирует все биты операнда (вычисляет одно дополнение). \`NOT операнд\`. Флаги не изменяет.

## \`TEST\` (Test Logical Compare)
*   **Тезисно:** Выполняет побитовую операцию "И" между операндами, результат не сохраняется, но устанавливаются флаги (\`ZF\`, \`SF\`, \`PF\`). \`TEST операнд1, операнд2\`. \`CF=0, OF=0\`. \`AF\` неопределен.

## \`SAL\`/\`SHL\` (Shift Arithmetic Left / Shift Logical Left)
*   **Тезисно:** Сдвигает биты операнда влево на указанное число разрядов. Выдвигаемый старший бит помещается во флаг \`CF\`. Младший бит заполняется нулем. \`SAL\` и \`SHL\` идентичны. \`SAL/SHL операнд, счетчик (1 или CL)\`.

## \`SAR\` (Shift Arithmetic Right)
*   **Тезисно:** Арифметический сдвиг вправо. Выдвигаемый младший бит помещается во флаг \`CF\`. Старший (знаковый) бит копируется, сохраняя знак числа. \`SAR операнд, счетчик (1 или CL)\`.

## \`SHR\` (Shift Logical Right)
*   **Тезисно:** Логический сдвиг вправо. Выдвигаемый младший бит помещается во флаг \`CF\`. Старший бит заполняется нулем. \`SHR операнд, счетчик (1 или CL)\`.

## \`RCL\` (Rotate through Carry Left)
*   **Тезисно:** Циклический сдвиг влево через флаг переноса (\`CF\`). Старший бит операнда помещается в \`CF\`, предыдущее значение \`CF\` помещается в младший бит операнда. \`RCL операнд, счетчик (1 или CL)\`.

## \`RCR\` (Rotate through Carry Right)
*   **Тезисно:** Циклический сдвиг вправо через флаг переноса (\`CF\`). Младший бит операнда помещается в \`CF\`, предыдущее значение \`CF\` помещается в старший бит операнда. \`RCR операнд, счетчик (1 или CL)\`.

## \`ROL\` (Rotate Left)
*   **Тезисно:** Циклический сдвиг влево. Старший бит операнда помещается в \`CF\` и одновременно в младший бит операнда. \`ROL операнд, счетчик (1 или CL)\`.

## \`ROR\` (Rotate Right)
*   **Тезисно:** Циклический сдвиг вправо. Младший бит операнда помещается в \`CF\` и одновременно в старший бит операнда. \`ROR операнд, счетчик (1 или CL)\`.

# 4. Инструкции управления потоком выполнения

## \`JMP\` (Jump)
*   **Тезисно:** Безусловный переход на указанную метку (адрес). Изменяет \`IP\` (и \`CS\` для \`FAR\` перехода). \`JMP метка\`.

## \`Jcc\` (Conditional Jump)
*   **Тезисно:** Условный переход на метку, если указанное условие \`cc\` (основанное на флагах) истинно. Примеры: \`JE\` (Jump if Equal, \`ZF=1\`), \`JNE\` (Jump if Not Equal, \`ZF=0\`), \`JC\`, \`JNC\`, \`JS\`, \`JG\`, и т.д. \`Jcc метка\`.

## \`CALL\` (Call Procedure)
*   **Тезисно:** Вызывает процедуру. Сохраняет адрес возврата (следующей инструкции) в стек и передает управление на адрес процедуры. \`CALL метка_процедуры\`.

## \`RET\` (Return from Procedure)
*   **Тезисно:** Возвращает управление из процедуры. Извлекает адрес возврата из стека в \`IP\` (и \`CS\` для \`FAR RET\`). Опционально может прибавить число к \`SP\` для очистки параметров со стека: \`RET [число_байт_параметров]\`.

## \`LOOP\` (Loop)
*   **Тезисно:** Уменьшает регистр \`CX\` на 1 и, если \`CX\` не равен нулю, выполняет короткий переход на указанную метку. \`LOOP метка\`.
    *   \`LOOPE\`/\`LOOPZ\`: \`DEC CX\`, переход если \`CX!=0\` и \`ZF=1\`.
    *   \`LOOPNE\`/\`LOOPNZ\`: \`DEC CX\`, переход если \`CX!=0\` и \`ZF=0\`.

## \`INT\` (Interrupt)
*   **Тезисно:** Вызывает программное прерывание с указанным номером (0-255). Сохраняет флаги, \`CS\` и \`IP\` в стек, сбрасывает \`TF\` и \`IF\` (если это не ловушка), затем передает управление обработчику прерывания по адресу из Таблицы Векторов Прерываний. \`INT номер_прерывания\`.

## \`IRET\` (Interrupt Return)
*   **Тезисно:** Возврат из обработчика прерывания. Восстанавливает \`IP\`, \`CS\` и регистр флагов из стека.

## \`CMP\` (Compare)
*   **Тезисно:** Сравнивает два операнда путем вычитания источника из приемника. Результат вычитания не сохраняется, но флаги (\`CF, ZF, SF, OF, PF, AF\`) устанавливаются как после \`SUB\`. \`CMP приемник, источник\`. Используется перед инструкциями \`Jcc\` или \`SETcc\`.

## \`SETcc\` (Set Byte on Condition)
*   **Тезисно:** (80386+) Устанавливает байтовый операнд (регистр или память) в 1, если условие \`cc\` (основанное на флагах) истинно, иначе устанавливает его в 0. \`SETcc регистр8_или_память\`.

# 5. Строковые инструкции

*(Обычно используют \`DS:SI\` как источник, \`ES:DI\` как приемник, \`CX\` как счетчик. Флаг \`DF\` определяет направление изменения \`SI\` и \`DI\`: \`DF=0\` (после \`CLD\`) - инкремент, \`DF=1\` (после \`STD\`) - декремент.)*

## \`MOVS\` (Move String) (\`MOVSB\`/\`MOVSW\`)
*   **Тезисно:** Копирует байт (\`MOVSB\`) или слово (\`MOVSW\`) из ячейки памяти \`DS:[SI]\` в \`ES:[DI]\`. Затем обновляет \`SI\` и \`DI\` в соответствии с флагом \`DF\`.

## \`CMPS\` (Compare String) (\`CMPSB\`/\`CMPSW\`)
*   **Тезисно:** Сравнивает байт (\`CMPSB\`) или слово (\`CMPSW\`) из \`DS:[SI]\` с \`ES:[DI]\`. Устанавливает флаги как \`CMP\`. Затем обновляет \`SI\` и \`DI\`.

## \`SCAS\` (Scan String) (\`SCASB\`/\`SCASW\`)
*   **Тезисно:** Сравнивает содержимое регистра \`AL\` (для \`SCASB\`) или \`AX\` (для \`SCASW\`) с байтом/словом в \`ES:[DI]\`. Устанавливает флаги как \`CMP\`. Затем обновляет \`DI\`.

## \`LODS\` (Load String) (\`LODSB\`/\`LODSW\`)
*   **Тезисно:** Загружает байт (\`LODSB\`) или слово (\`LODSW\`) из \`DS:[SI]\` в регистр \`AL\` или \`AX\` соответственно. Затем обновляет \`SI\`.

## \`STOS\` (Store String) (\`STOSB\`/\`STOSW\`)
*   **Тезисно:** Сохраняет содержимое регистра \`AL\` (для \`STOSB\`) или \`AX\` (для \`STOSW\`) в ячейку памяти \`ES:[DI]\`. Затем обновляет \`DI\`.

## \`INS\` (Input String from Port) (\`INSB\`/\`INSW\`)
*   **Тезисно:** (80186+) Вводит байт (\`INSB\`) или слово (\`INSW\`) из порта, адрес которого указан в \`DX\`, в ячейку памяти \`ES:[DI]\`. Затем обновляет \`DI\`.

## \`OUTS\` (Output String to Port) (\`OUTSB\`/\`OUTSW\`)
*   **Тезисно:** (80186+) Выводит байт (\`OUTSB\`) или слово (\`OUTSW\`) из ячейки памяти \`DS:[SI]\` в порт, адрес которого указан в \`DX\`. Затем обновляет \`SI\`.

## \`Префиксы REP/REPE/REPNE\` (Repeat Prefixes)
*   **Тезисно:** Используются перед строковыми инструкциями для их многократного повторения, пока \`CX\` не станет 0.
    *   \`REP\`: Повторять \`CX\` раз (для \`MOVS\`, \`STOS\`, \`LODS\`, \`INS\`, \`OUTS\`). Уменьшает \`CX\` на каждой итерации.
    *   \`REPE\`/\`REPZ\` (Repeat if Equal/Zero): Повторять, пока \`CX != 0\` **и** \`ZF = 1\` (для \`CMPS\`, \`SCAS\`).
    *   \`REPNE\`/\`REPNZ\` (Repeat if Not Equal/Not Zero): Повторять, пока \`CX != 0\` **и** \`ZF = 0\` (для \`CMPS\`, \`SCAS\`).

# 6. Инструкции ввода-вывода

## \`IN\` (Input from Port)
*   **Тезисно:** Вводит данные (байт или слово) из указанного порта ввода-вывода в регистр \`AL\` (для байта) или \`AX\` (для слова). \`IN AL, порт8_имм\` или \`IN AX, порт8_имм\` или \`IN AL, DX\` или \`IN AX, DX\` (адрес порта в \`DX\`).

## \`OUT\` (Output to Port)
*   **Тезисно:** Выводит данные (байт или слово) из регистра \`AL\` (для байта) или \`AX\` (для слова) в указанный порт ввода-вывода. \`OUT порт8_имм, AL\` или \`OUT порт8_имм, AX\` или \`OUT DX, AL\` или \`OUT DX, AX\` (адрес порта в \`DX\`).

# 7. Инструкции управления флагами и процессором

## \`CLC\` (Clear Carry Flag)
*   **Тезисно:** Сбрасывает (устанавливает в 0) флаг переноса (\`CF\`).

## \`CLD\` (Clear Direction Flag)
*   **Тезисно:** Сбрасывает (устанавливает в 0) флаг направления (\`DF\`). Строковые операции будут инкрементировать \`SI\`/\`DI\`.

## \`CLI\` (Clear Interrupt Flag)
*   **Тезисно:** Сбрасывает (устанавливает в 0) флаг разрешения прерываний (\`IF\`). Маскируемые аппаратные прерывания запрещаются.

## \`STC\` (Set Carry Flag)
*   **Тезисно:** Устанавливает (в 1) флаг переноса (\`CF\`).

## \`STD\` (Set Direction Flag)
*   **Тезисно:** Устанавливает (в 1) флаг направления (\`DF\`). Строковые операции будут декрементировать \`SI\`/\`DI\`.

## \`STI\` (Set Interrupt Flag)
*   **Тезисно:** Устанавливает (в 1) флаг разрешения прерываний (\`IF\`). Маскируемые аппаратные прерывания разрешаются.

## \`CMC\` (Complement Carry Flag)
*   **Тезисно:** Инвертирует (изменяет на противоположное) значение флага переноса (\`CF\`).

## \`NOP\` (No Operation)
*   **Тезисно:** Ничего не делает. Занимает 1 байт и некоторое время на выполнение. Используется для выравнивания кода или создания коротких задержек. \`XCHG AX,AX\` часто используется как NOP для процессоров 8086.
`,
  },
  "Welcome": "### Welcome to the Markdown Viewer!\n\nThis is a simple application to display your markdown texts. Please select an item from the navigation panel on the left to get started.\n\n- You can organize texts into groups and subgroups.\n- Clicking on a text title will display its content here."
}; 
