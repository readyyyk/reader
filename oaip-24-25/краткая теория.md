## 1. Процедуры. Синтаксис. Связь без параметров.
- **Процедура:** Поименованная группа операторов.
- **Синтаксис:** `procedure Имя(<параметры>); begin ... end;`
- **Вызов:** `Имя(<параметры>);`
- **Связь без параметров:** Через **глобальные переменные**. Считается дурным тоном, так как усложняет код, снижает гибкость и переиспользуемость.

## 2. Параметры-значения.
- **Назначение:** Передача данных **В** подпрограмму.
- **Механизм:** В стек передается **КОПИЯ** значения. Оригинал **НЕ** изменяется.
- **Синтаксис:** `procedure Имя(Параметр: Тип);`
- **Фактический параметр:** Любое выражение.

## 3. Параметры-переменные и параметры-константы.
- **Параметр-переменная (`var`):**
    - **Назначение:** Возврат результата **ИЗ** подпрограммы, изменение оригинала.
    - **Механизм:** В стек передается **АДРЕС** переменной. Изменение параметра меняет оригинал.
    - **Синтаксис:** `procedure Имя(var Параметр: Тип);`
- **Параметр-константа (`const`):**
    - **Назначение:** Эффективная передача данных **В** подпрограмму с защитой от изменений.
    - **Механизм:** Способ передачи (копия или адрес) выбирает компилятор для оптимизации. Изменение внутри **ЗАПРЕЩЕНО**.
    - **Синтаксис:** `procedure Имя(const Параметр: Тип);`

## 4. Параметры без типа.
- **Назначение:** Создание универсальных подпрограмм для данных любого типа (например, копирование памяти).
- **Синтаксис:** `procedure Имя(var Данные);` или `const`.
- **Способы работы:** 1. **`absolute`**: наложение переменной нужного типа. 2. **Явное приведение типов**.

## 5. Параметры open array.
- **Назначение:** Передача в подпрограмму одномерных массивов разной длины.
- **Синтаксис:** `procedure Имя(var A: array of Тип);`
- **Особенности:** Не является динамическим массивом. Внутри подпрограммы нумерация всегда с 0. `Low(A)` всегда 0.

## 6. Функции.
- **Функция:** Процедура, **возвращающая значение**.
- **Синтаксис:** `function Имя(<параметры>): Тип_результата;`
- **Возврат значения:** Через присваивание имени функции (`Имя := ...;`) или переменной `Result` (`Result := ...;`).
- **Вызов:** Является выражением, может использоваться в других выражениях. `x := MyFunc(a) + 1;`

## 7. Рекурсивные подпрограммы. Явная рекурсия.
- **Рекурсия:** Определение понятия через само себя. В коде — вызов подпрограммой самой себя.
- **Виды:** Явная (прямая) и неявная (косвенная).
- **Достоинства:** Элегантность и краткость кода для рекурсивных задач.
- **Недостатки:** Расход памяти в стеке, медленнее итеративных аналогов.
- **Явная рекурсия:** Подпрограмма вызывает саму себя. Пример: функция вычисления факториала.

## 8. Директивы подпрограмм. Неявная рекурсия.
- **Директивы:** Ключевые слова после заголовка, управляющие компиляцией.
    - **`forward`:** Опережающее объявление. Необходимо для неявной рекурсии.
    - **`inline`:** Встраивание кода функции в место вызова для ускорения.
    - **`external`:** Реализация находится во внешней библиотеке (DLL).
- **Неявная рекурсия:** Процедура А вызывает Б, а Б вызывает А. Требует `forward`.

## 9. Библиотечные модули пользователя. Структура.
- **Модуль (`unit`):** Отдельно компилируемый файл (`.pas`) для повторного использования кода.
- **Структура:**
    - **`interface`:** Публичная часть. Описания типов, констант, переменных, заголовки подпрограмм, доступные извне.
    - **`implementation`:** Скрытая часть. Реализация подпрограмм и локальные описания.
    - **`initialization` (необязательно):** Код, выполняемый при загрузке модуля.
    - **`finalization` (необязательно):** Код, выполняемый при выгрузке модуля.

## 10. Особенности работы с библиотечными модулями.
- **Порядок подключения:** Модули в `uses` инициализируются в порядке их перечисления.
- **Конфликты имен:** Если имена совпадают, используется имя из последнего подключенного модуля. Для доступа к другим — `ИмяМодуля.ИмяЭлемента`.
- **Циклические ссылки:** В `implementation` разрешаются компилятором. В `interface` — требуют выноса общих типов в третий модуль.

## 11. Записи.
- **Запись (`record`):** Структура данных из полей разных типов.
- **Синтаксис:** `type TMyRec = record Поле1: Тип1; Поле2: Тип2; end;`
- **Доступ к полям:** Через точку: `Переменная.Поле`.
- **Операции:** Для всей записи — только присваивание (`:=`). Для полей — любые, соответствующие их типу.

## 12. Записи с вариантами.
- **Назначение:** Создание структур, которые могут хранить разные наборы полей в одной области памяти.
- **Синтаксис:** `case Поле_признака: Тип_признака of ...` внутри `record`.
- **Особенности:**
    - Все варианты используют **одну и ту же область памяти**.
    - Размер определяется по **наибольшему** варианту.
    - Компилятор **не контролирует** соответствие значения поля-признака и используемых полей варианта.

## 13. Оператор присоединения (`with`).
- **Назначение:** Упрощает доступ к полям записи, избавляя от повторного написания имени переменной-записи.
- **Формат:** `with ПеременнаяЗаписи do begin ... end;`
- **Сокращенная форма:** `with Запись1, Запись2 do ...`
- **Конфликт имен:** Приоритет у той записи, что указана правее (ближе к `do`).

## 14. Множественный тип (`set`).
- **Множество:** Неупорядоченный набор уникальных элементов одного базового типа.
- **Базовый тип:** Любой порядковый тип с числом элементов до 256 (коды `0..255`).
- **Представление в памяти:** Битовая карта (1 — элемент есть, 0 — элемента нет). 1-32 байта.
- **Конструктор:** `[элемент1, элемент2, диапазон..]` (например, `[1, 3, 5..10]`).

## 15. Множественные выражения и операции.
- **Операции:**
    - `+` (объединение), `*` (пересечение), `-` (разность).
    - `=`, `<>`, `<=` (подмножество), `>=` (надмножество).
    - `in` (проверка вхождения элемента).
- **Ввод-вывод:** Прямого нет. Организуется поэлементно через цикл и проверку `in`.
- **Процедуры:** `Include(S, E)` (добавить элемент), `Exclude(S, E)` (удалить элемент).

## 16. Типизованные константы-записи и -множества.
- **Назначение:** Присвоение начальных значений сложным типам (записям, множествам). По сути — инициализированная переменная.
- **Синтаксис записи:** `const Имя: Тип = (Поле1: Значение1; Поле2: Значение2);`
- **Синтаксис множества:** `const Имя: Тип = [Элементы];`

## 17. Файлы. Логический и физический.
- **Физический файл:** Файл на диске (`data.txt`).
- **Логический файл:** Файловая переменная в программе (`var F: TextFile;`).
- **Доступ:**
    - **Последовательный:** Элементы обрабатываются по порядку (текстовые файлы).
    - **Прямой:** Доступ к любому элементу по его номеру (типизированные и нетипизированные файлы).
- **Типы:** Текстовые (`Text`), с типом (`file of Type`), без типа (`file`).

## 18. Процедура `Assign`/`AssignFile`.
- **Назначение:** Связывает файловую переменную в коде с физическим файлом на диске.
- **Формат:** `AssignFile(var F; ИмяФайла: String);`
- **Пути:**
    - **Абсолютный:** `C:\Docs\file.txt`.
    - **Относительный:** `file.txt` (относительно каталога программы).
- **Логические устройства:** `CON` (консоль), `PRN` (принтер), `NUL` (пустое устройство).

## 19. Файлы с типом.
- **Назначение:** Хранение однотипных структурированных данных.
- **Синтаксис:** `var F: file of Тип;`
- **Открытие:**
    - `Rewrite(F)`: Создает новый пустой файл. Старый стирается.
    - `Reset(F)`: Открывает существующий файл.
    - **Особенность:** После открытия доступны и чтение (`Read`), и запись (`Write`).
- **Закрытие:** `CloseFile(F)` (обязательно).

## 20. Прямой доступ к файлам с типом.
- **Назначение:** Чтение/запись любого элемента по его номеру (индексу). Нумерация с 0.
- **Основные подпрограммы:**
    - `Seek(F, N)`: Переместить указатель на компонент с номером `N`.
    - `FileSize(F)`: Вернуть количество компонентов в файле.
    - `FilePos(F)`: Вернуть номер текущего компонента.

## 21. Текстовые файлы (чтение).
- **Назначение:** Хранение текстовой информации, читаемой человеком.
- **Синтаксис:** `var F: Text;` или `TextFile`.
- **Открытие для чтения:** `Reset(F)` — открывает в режиме **только для чтения**.
- **Процедуры чтения:**
    - `Read(F, V)`: Читает значение, преобразуя из текста в тип переменной `V`.
    - `ReadLn(F, V)`: Делает то же, что и `Read`, но после этого переходит на начало следующей строки.

## 22. Текстовые файлы (запись).
- **Открытие для записи:**
    - `Rewrite(F)`: Создает новый файл **только для записи**.
    - `Append(F)`: Открывает существующий файл для **дозаписи в конец**.
- **Процедуры записи:**
    - `Write(F, E)`: Записывает значение, преобразуя из типа выражения `E` в текст.
    - `WriteLn(F, E)`: Делает то же, что и `Write`, но после этого добавляет маркер конца строки.
- **Форматирование:** `Write(E:Width)` (ширина поля), `Write(E:Width:Decimals)` (для вещественных чисел).

## 23. Буфер ввода-вывода для текстовых файлов.
- **Буфер:** Участок памяти для временного хранения данных при обмене с файлом, повышает скорость.
- **Процедуры управления:**
    - `SetTextBuf(F, Buf, Size)`: Назначает файлу `F` пользовательский буфер `Buf`.
    - `Flush(F)`: Принудительно записывает содержимое буфера на диск.

## 24. Сравнение текстовых и типизированных файлов.
| Характеристика | Файл с типом | Текстовый файл |
|---|---|---|
| **Представление** | Двоичное, как в памяти | Символьное, текстовое |
| **Доступ** | Прямой | Последовательный |
| **Скорость** | Быстрее (нет преобразований) | Медленнее |
| **Размер** | Компактнее для чисел | Компактнее для текста |
| **Читаемость** | Нечитаем человеком | Читаем человеком |

## 25. Файлы без типа.
- **Назначение:** Максимально быстрый, низкоуровневый обмен данными (например, копирование файлов).
- **Синтаксис:** `var F: file;`
- **Процедуры обмена:**
    - `BlockRead(F, Buf, Count, [Res])`: Читает `Count` блоков в `Buf`.
    - `BlockWrite(F, Buf, Count, [Res])`: Пишет `Count` блоков из `Buf`.
- **Размер блока:** Задается в `Reset(F, RecSize)` и `Rewrite(F, RecSize)`.

## 26. Проверка операций ввода-вывода.
- **Назначение:** Самостоятельная обработка ошибок файловых операций.
- **Механизм:**
    - `{$I-}`: Отключить стандартную проверку (программа не "упадет" при ошибке).
    - `IOResult`: Функция, возвращающая код последней операции (0 = успех, >0 = код ошибки).
    - `{$I+}`: Включить проверку обратно.

## 27. Ссылочный тип (указатель).
- **Назначение:** Хранение адреса данных в памяти. Используется для работы с динамической памятью и создания сложных структур (списки, деревья).
- **Виды:** Типизированный (`^Тип`) и нетипизированный (`Pointer`).
- **Операции:**
    - `@`: Взять адрес переменной (`P := @X;`).
    - `^`: Разыменовать указатель, получить доступ к данным (`P^ := 10;`).
- **Специальное значение:** `nil` — указатель никуда не ссылается.

## 28. Процедуры `New` и `Dispose`.
- **Назначение:** Высокоуровневая работа с динамической памятью для **типизированных** указателей.
- `New(P)`: Выделяет память под один элемент того типа, на который указывает `P`.
- `Dispose(P)`: Освобождает память, ранее выделенную `New`.
- **Преимущество:** Простота и безопасность, не нужно указывать размер.

## 29. Процедуры `GetMem` и `FreeMem`.
- **Назначение:** Низкоуровневая работа с динамической памятью.
- `GetMem(P, Size)`: Выделяет блок памяти размером `Size` байт.
- `FreeMem(P, [Size])`: Освобождает память, ранее выделенную `GetMem`.
- **Преимущество:** Гибкость, позволяет выделять блоки любого размера (например, для динамических массивов).

## 30. Строковый тип в Delphi.
- **Представление:** Управляемый тип. Переменная — это указатель на блок в куче.
- **Структура в памяти:** `[Счетчик ссылок][Длина][Символы строки][#0]`.
- **Управление памятью:**
    - **Подсчет ссылок:** Присваивание (`S2:=S1`) не копирует данные, а увеличивает счетчик. Память освобождается, когда счетчик становится равен 0.
    - **Копирование при записи:** При попытке изменить строку со счетчиком > 1 создается ее копия.

## 31. Директива `absolute`.
- **Назначение:** Позволяет разместить переменную поверх другой переменной или по абсолютному адресу в памяти.
- **Принцип:** Создает псевдоним для уже существующей области памяти, позволяя интерпретировать ее как данные другого типа.
- **Пример:** `var Num:Integer; Bytes: array[0..1] of Byte absolute Num;`

## 32. Зарезервированное слово `packed`.
- **Назначение:** Указывает компилятору располагать элементы структуры (записи, массива) в памяти вплотную друг к другу, **отключая выравнивание**.
- **Влияние:** Экономит память, но может замедлить скорость доступа к полям.
- **Применение:** Необходимо для работы с файловыми форматами, сетевыми протоколами, где требуется точное бинарное представление данных.
