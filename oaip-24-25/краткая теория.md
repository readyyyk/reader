Конечно, вот краткие ответы на все экзаменационные вопросы в формате Markdown.

### 1\. Процедуры. Синтаксис объявления процедур. Вызов процедуры. Организация связи по данным при использовании процедур без параметров. Пример.

*   **Подпрограмма** — поименованная, логически законченная группа операторов. Делятся на процедуры и функции.
*   **Синтаксис объявления:** `procedure <Имя>(<Параметры>); begin ... end;`
*   **Вызов:** `<Имя>(<Параметры>);`
*   **Связь без параметров:** Осуществляется через **глобальные переменные**, объявленные в основной программе. Такой подход считается **дурным тоном**, так как усложняет логику и повторное использование кода.

```pascal
var GlobalX: Integer; // Глобальная переменная

procedure PrintGlobalX;
begin
  WriteLn(GlobalX);
end;

begin
  GlobalX := 100;
  PrintGlobalX; // Процедура использует глобальную переменную
end.
```

### 2\. Виды формальных параметров подпрограмм. Параметры-значения. Назначение, синтаксис. Механизм организации взаимосвязи с фактическими параметрами при использовании параметров-значений. Пример.

*   **Назначение:** Для передачи **входных данных** в подпрограмму.
*   **Синтаксис:** `procedure MyProc(ValueParam: Integer);`
*   **Механизм:** При вызове создается **локальная копия** фактического параметра. Все изменения внутри подпрограммы затрагивают только эту копию, **оригинал остается неизменным**.

### 3\. Параметры-переменные и параметры-константы. Назначение, синтаксис. Механизм организации взаимосвязи с фактическими параметрами при использовании параметров-переменных и параметров-констант. Пример.

*   **Параметры-переменные (`var`)**
    *   **Назначение:** Для **возврата результатов** из подпрограммы и изменения исходных данных.
    *   **Синтаксис:** `procedure MyProc(var VarParam: Integer);`
    *   **Механизм:** Передается **адрес** фактического параметра. Формальный параметр становится псевдонимом фактического, все изменения происходят с оригиналом.

*   **Параметры-константы (`const`)**
    *   **Назначение:** Для передачи данных, которые **не должны изменяться** внутри подпрограммы. Эффективно для больших структур (строк, записей).
    *   **Синтаксис:** `procedure MyProc(const ConstParam: string);`
    *   **Механизм:** Способ передачи (по значению или по адресу) выбирает компилятор. Изменение параметра внутри подпрограммы запрещено.

### 4\. Параметры без типа. Назначение, синтаксис. Способы обеспечения совместимости с фактическими параметрами. Примеры.

*   **Назначение:** Создание универсальных подпрограмм, способных работать с данными любого типа (например, копирование памяти).
*   **Синтаксис:** `procedure MyProc(var UntypedParam);` или `(const UntypedParam);`
*   **Способы работы:**
    1.  **Директива `absolute`:** "Накладывание" локальной переменной известного типа на ту же область памяти.
    2.  **Явное приведение типов:** Временная интерпретация бестипового параметра как переменной нужного типа.

### 5\. Параметры процедурного типа. Назначение, синтаксис. Условия совместимости с фактическими параметрами. Пример.

*   **Назначение:** Передача одной подпрограммы в качестве параметра в другую. Используется для реализации "обратных вызовов" (callbacks) и создания обобщенных алгоритмов (например, сортировка с пользовательской функцией сравнения).
*   **Синтаксис:**
    ```pascal
    type TMyFunction = function(X: Integer): Integer;
    procedure Process(Func: TMyFunction);
    ```
*   **Совместимость:** Передаваемая подпрограмма должна **полностью совпадать** с процедурным типом по количеству и типам параметров, а также по типу возвращаемого значения.

### 6\. Функции. Описание функций. Вызов функции. Возврат значения из функции. Пример.

*   **Функция** — подпрограмма, которая **возвращает значение** определенного типа.
*   **Описание:** `function <Имя>(<Параметры>): <Тип_результата>;`
*   **Вызов:** Используется в выражениях, т.к. сам вызов является значением. `VarX := MyFunc(Y);`
*   **Возврат значения:**
    1.  Через имя функции: `MyFunc := 10;`
    2.  Через переменную `Result`: `Result := 10;` (рекомендуется).

### 7\. Рекурсивные подпрограммы. Виды рекурсии. Достоинства и недостатки рекурсивной записи подпрограмм. Явная рекурсия. Пример.

*   **Рекурсия** — вызов подпрограммой самой себя.
*   **Виды:**
    *   **Явная (прямая):** `A` вызывает `A`.
    *   **Неявная (косвенная):** `A` вызывает `B`, `B` вызывает `A`.
*   **Обязательное условие:** Наличие **условия выхода** (базового случая) для прекращения вызовов.
*   **Достоинства:** Элегантность и краткость кода для рекурсивных по своей природе задач.
*   **Недостатки:** Расход памяти в стеке (риск переполнения), обычно медленнее итеративных аналогов.

### 8\. Директивы подпрограмм. Неявная рекурсия. Пример.

*   **Директивы** — ключевые слова, управляющие компиляцией подпрограммы.
    *   `forward`: Опережающее описание, необходимое для неявной рекурсии.
    *   `inline`: Рекомендует компилятору вставить код подпрограммы в место вызова.
    *   `external`: Указывает, что реализация находится во внешней библиотеке (DLL).
*   **Неявная рекурсия** — взаимный вызов двух или более подпрограмм. Реализуется с помощью `forward`.

### 9\. Библиотечные модули пользователя. Назначение модуля. Структура модуля. Синтаксис и назначение разделов модуля. Пример.

*   **Модуль (`unit`)** — отдельно компилируемый файл (`.pas`) для повторного использования кода.
*   **Структура и разделы:**
    *   `unit <Имя>;` — заголовок.
    *   `interface` — публичная часть, видимая извне (объявления типов, заголовки подпрограмм).
    *   `implementation` — приватная часть (тела подпрограмм, скрытые элементы).
    *   `initialization` (необязательно) — код, выполняемый при загрузке модуля.
    *   `finalization` (необязательно) — код, выполняемый при выгрузке модуля.
    *   `end.` — конец модуля.

### 10\. Особенности работы с библиотечными модулями пользователя. Пример.

*   **Порядок подключения:** Модули в секции `uses` инициализируются в порядке их перечисления.
*   **Конфликты имен:** Если в разных модулях есть одноименные идентификаторы, доступен будет тот, чей модуль в `uses` указан правее. Для явного обращения используется `ИмяМодуля.Идентификатор`.
*   **Циклические ссылки:** Если модуль `U1` использует `U2` в секции `interface`, а `U2` использует `U1` в `interface`, возникает ошибка компиляции. Проблема решается выносом общих типов в третий модуль или использованием `implementation` для одной из ссылок.

### 11\. Записи. Синтаксис задания. Записи без вариантной части. Операции над записями и над полями. Пример.

*   **Запись (`record`)** — структура данных из фиксированного набора полей, возможно, разных типов.
*   **Синтаксис:** `type TMyRec = record Field1: Type1; ... end;`
*   **Доступ к полям:** Через точку `MyVar.Field1`.
*   **Операции:** К полям применимы операции их типов. Для всей записи целиком определена только одна операция — **присваивание (`:=`)** другой записи того же типа.

### 12\. Записи с вариантами. Синтаксис задания. Особенности задания записей с полем признака и без него. Пример.

*   **Назначение:** Позволяют иметь различные наборы полей в одной записи.
*   **Синтаксис:** Используется конструкция `case <Поле_признака>: <Тип_признака> of ...` внутри `record`.
*   **Особенности:**
    *   Все варианты занимают **одну и ту же область памяти**. Размер определяется по наибольшему варианту.
    *   Поле-признак (тэг) необязательно.
    *   Компилятор не контролирует доступ к полям, что потенциально опасно.

### 13\. Оператор присоединения. Назначение. Формат. Полная и сокращенная формы оператора присоединения. Примеры использования.

*   **Назначение:** Упрощает доступ к полям записи, избавляя от повторения имени переменной.
*   **Формат:** `with <Переменная_запись> do begin ... end;`
*   **Сокращенная форма:** `with Rec1, Rec2 do ...` эквивалентна вложенным `with Rec1 do with Rec2 do ...`.
*   Внутри блока `with` к полям можно обращаться напрямую по их именам.

### 14\. Множественный тип. Синтаксис задания. Базовый тип множества. Представление в памяти. Конструктор множества. Пример.

*   **Множество (`set`)** — неупорядоченная коллекция уникальных элементов одного базового типа.
*   **Базовый тип:** Любой порядковый тип (Integer, Char, Enum), чьи значения лежат в диапазоне `0..255`.
*   **Синтаксис:** `type TMySet = set of <Базовый_тип>;`
*   **Представление в памяти:** Битовая карта. Один бит на каждый возможный элемент базового типа (1 — есть, 0 — нет).
*   **Конструктор:** Задание множества в квадратных скобках: `[1, 5, 10..20]`. `[]` — пустое множество.

### 15\. Множественные выражения. Операции и встроенные функции над множествами. Ввод-вывод множественных переменных. Пример.

*   **Операции:**
    *   `+` (объединение), `*` (пересечение), `-` (разность).
    *   `=`, `<>`, `<=` (подмножество), `>=` (надмножество).
    *   `in` (проверка принадлежности элемента).
*   **Встроенные функции:** `Include(Set, Elem)` и `Exclude(Set, Elem)` для добавления и удаления элемента.
*   **Ввод-вывод:** Не поддерживается напрямую. Организуется поэлементно циклом по всем возможным значениям базового типа с проверкой `in`.

### 16\. Типизованные константы-записи (с вариантами и без) и константы-множества. Назначение. Синтаксис задания. Примеры использования.

*   **Назначение:** Позволяют объявить переменную с начальным значением прямо в разделе `const`.
*   **Синтаксис (запись):** `const MyRec: TRec = (Field1: Val1; Field2: Val2);`
*   **Синтаксис (множество):** `const MySet: TSet = [Elem1, Elem2];`
*   По сути, это **инициализированные переменные**.

### 17\. Файлы. Логический и физический файл. Способы доступа к элементам файла. Типы файлов. Синтаксис задания. Пример.

*   **Физический файл:** Данные на диске (`data.txt`).
*   **Логический файл:** Переменная в программе (`var F: ...`), через которую идет работа.
*   **Способы доступа:**
    *   **Последовательный:** Чтение/запись по порядку (для `TextFile`).
    *   **Прямой:** Доступ к любому элементу по номеру (для `file of Type`, `file`).
*   **Типы файлов:**
    *   `file of <Type>` (типизированный).
    *   `Text` или `TextFile` (текстовый).
    *   `file` (без типа).

### 18\. Процедура Assign/AssignFile. Назначение. Формат. Логические имена устройств ввода-вывода. Пример.

*   **Назначение:** Связывает логическую файловую переменную с физическим файлом или устройством. **Обязательна** перед открытием файла.
*   **Формат:** `AssignFile(var F; Name: string);`
*   `Name` может быть абсолютным (`C:\file.txt`) или относительным (`file.txt`) путем.
*   **Логические имена:** `CON` (консоль), `PRN` (принтер), `NUL` ("пустое" устройство).

### 19\. Файлы с типом. Синтаксис задания. Процедуры открытия, чтения и записи, определенные над файлами с типом. Пример.

*   **Синтаксис:** `type FType = file of <Компонентный_тип>;`
*   **Процедуры:**
    *   `Reset(F)`: Открывает существующий файл.
    *   `Rewrite(F)`: Создает новый пустой файл (стирая старый).
    *   После `Reset` и `Rewrite` файл доступен **и для чтения, и для записи**.
    *   `Read(F, Var)`: Читает один компонент.
    *   `Write(F, Var)`: Записывает один компонент.
    *   `CloseFile(F)`: Обязательное закрытие файла.

### 20\. Организация прямого доступа к элементам файлов с типом. Встроенные функции, определенные над файлами с типом. Закрытие файлов с типом. Примеры.

*   **Прямой доступ** осуществляется с помощью специальных процедур и функций. Компоненты нумеруются с 0.
*   `Seek(F, N)`: Перемещает указатель на компонент с номером N.
*   `FileSize(F)`: Возвращает количество компонентов в файле.
*   `FilePos(F)`: Возвращает номер текущего компонента.
*   `CloseFile(F)`: Закрывает файл, сохраняя все изменения на диске.

### 21\. Текстовые файлы. Синтаксис задания. Процедуры и функции, обеспечивающие чтение из текстовых файлов, и их особенности по сравнению с файлами с типом. Допустимые типы вводимых переменных. Пример.

*   **Синтаксис:** `var F: TextFile;` или `var F: Text;`
*   **Особенности чтения:**
    *   `Reset(F)`: Открывает файл в режиме **только для чтения**.
    *   `Read(F, V)`: Читает данные, автоматически преобразуя их из текста в тип переменной `V`.
    *   `ReadLn(F, V)`: Делает то же, что и `Read`, а затем перемещает указатель на начало следующей строки.
*   **Допустимые типы:** `Char`, `String`, целочисленные и вещественные типы.

### 22\. Процедуры и функции, обеспечивающие запись в текстовые файлы, и их особенности по сравнению с файлами с типом. Допустимые типы выводимых переменных. Размещение информации в строке по умолчанию. Управление размещением информации по позициям строки. Пример.

*   **Особенности записи:**
    *   `Rewrite(F)`: Открывает файл в режиме **только для записи**.
    *   `Append(F)`: Открывает существующий файл для **дозаписи в конец**.
    *   `Write(F, V)`: Преобразует значение `V` в текст и записывает в файл.
    *   `WriteLn(F, V)`: Делает то же, что `Write`, и добавляет маркер конца строки.
*   **Допустимые типы:** Как для чтения, плюс `Boolean` (выводится 'TRUE'/'FALSE').
*   **Форматирование:** `Write(V:Width:Decimals)` позволяет задать ширину поля и количество знаков после запятой для вещественных чисел.

### 23\. Процедуры, управляющие работой буфера ввода вывода для текстовых файлов. Пример.

*   **Буфер** — область памяти для временного хранения данных, повышающая скорость файловых операций.
*   **Процедуры:**
    *   `SetTextBuf(F, Buf, Size)`: Назначает файлу `F` пользовательский буфер `Buf`. Вызывается после `AssignFile`, но до `Reset`/`Rewrite`.
    *   `Flush(F)`: Принудительно записывает содержимое буфера вывода на диск.

### 24\. Сравнительная характеристика внутренней структуры представления информации в текстовом файле и файле с типом. Достоинства и недостатки использования текстового файла и файла с типом.

*   **Файл с типом:**
    *   **Структура:** Двоичная, данные хранятся как в памяти.
    *   **Достоинства:** Быстрый, компактный для чисел, поддерживает прямой доступ.
    *   **Недостатки:** Нечитаем для человека, не универсален.
*   **Текстовый файл:**
    *   **Структура:** Символьная, данные представлены как текст.
    *   **Достоинства:** Читаем для человека, универсальный формат.
    *   **Недостатки:** Медленнее из-за преобразований типов, только последовательный доступ.

### 25\. Файлы без типа. Синтаксис задания. Назначение. Факторы повышения скорости обмена информацией. Процедуры и функции, определенные над файлами без типа. Пример.

*   **Назначение:** Максимально быстрый, низкоуровневый обмен данными.
*   **Синтаксис:** `var F: file;`
*   **Скорость:** Достигается за счет отсутствия преобразований типов и обмена большими блоками.
*   **Процедуры:**
    *   `Reset(F, RecSize)` и `Rewrite(F, RecSize)`: `RecSize` — размер блока в байтах.
    *   `BlockRead(F, Buf, Count, Result)`: Чтение `Count` блоков.
    *   `BlockWrite(F, Buf, Count, Result)`: Запись `Count` блоков.

### 26\. Проверка операций ввода-вывода. Пример.

*   **Назначение:** Самостоятельная обработка файловых ошибок без аварийного завершения программы.
*   **Механизм:**
    1.  Отключить проверку директивой `{$I-}`.
    2.  Выполнить операцию ввода-вывода.
    3.  Включить проверку обратно `{$I+}`.
    4.  Проверить результат с помощью функции `IOResult`.
*   `IOResult` возвращает `0` при успехе или код ошибки в противном случае.

### 27\. Ссылочный тип. Назначение. Синтаксис задания. Представление в памяти. Виды указателей. Операции над указателями. Пример.

*   **Назначение:** Хранение адреса данных в памяти. Используется для работы с динамической памятью и создания динамических структур данных (списки, деревья).
*   **Синтаксис:** `type PMyType = ^TMyType;`
*   **Виды:**
    *   **Типизированный (`^Type`)**: "Знает" тип данных, на которые ссылается.
    *   **Нетипизированный (`Pointer`)**: Может ссылаться на что угодно.
*   **`nil`:** Специальное значение, означающее "указатель никуда не ссылается".
*   **Операции:**
    *   `@`: Взятие адреса переменной.
    *   `^`: Разыменование (доступ к данным по адресу). `P` — адрес, `P^` — данные.

### 28\. Процедуры New и Dispose. Назначение. Достоинства и недостатки их использования. Пример.

*   **Назначение:** Высокоуровневое управление динамической памятью для **типизированных** указателей.
*   `New(P)`: Выделяет память под один элемент того типа, на который указывает `P`. Размер определяется автоматически.
*   `Dispose(P)`: Освобождает память, ранее выделенную `New(P)`.
*   **Достоинства:** Простота, безопасность (не нужно считать размер).
*   **Недостатки:** Негибкость (только один элемент), работает только с типизированными указателями.

### 29\. Процедуры GetMem и FreeMem. Назначение. Достоинства и недостатки их использования. Пример.

*   **Назначение:** Низкоуровневое управление динамической памятью.
*   `GetMem(P, Size)`: Выделяет блок памяти размером `Size` байт.
*   `FreeMem(P)`: Освобождает память, ранее выделенную `GetMem`.
*   **Достоинства:** Гибкость (любой размер), универсальность (работает с `Pointer`).
*   **Недостатки:** Менее безопасно (ответственность за расчет размера на программисте).

### 30\. Строковый тип в Delphi. Представление в памяти. Автоматическое управление памятью для Delphi строк.

*   **Тип `String`** в Delphi — это **управляемый тип**. Переменная является указателем.
*   **Представление в памяти:** Блок в куче, содержащий заголовок (счетчик ссылок, длина) и сами символы, завершенные `#0`.
*   **Автоматическое управление памятью:**
    *   **Подсчет ссылок:** При присваивании (`S2 := S1`) данные не копируются, а увеличивается счетчик ссылок. Память освобождается, когда счетчик становится равен нулю.
    *   **Копирование при записи:** Реальное копирование данных происходит только при попытке изменить строку, на которую есть несколько ссылок.

### 31\. Директива absolute. Принцип работы. Пример.

*   **Назначение:** Позволяет разместить переменную поверх другой переменной или по абсолютному адресу в памяти.
*   **Принцип:** Создает псевдоним для существующей области памяти. Это позволяет интерпретировать одни и те же байты как данные разных типов.
*   **Синтаксис:** `var V1: Type1; V2: Type2 absolute V1;`
*   Использование с абсолютным адресом (`absolute $B800:0000`) в современных ОС практически не применяется.

### 32\. Зарезервированное слово packed. Влияние на представление в памяти записей и массивов.

*   **Назначение:** Указывает компилятору упаковывать элементы структуры (записи, массива) максимально плотно, отключая **выравнивание** по границам слов/двойных слов.
*   **Влияние:**
    *   **Плюс:** Экономит память. Структура данных в памяти становится предсказуемой и не содержит "пустых" байтов. Важно для работы с файлами и сетевыми протоколами.
    *   **Минус:** Может замедлить доступ к элементам структуры, так как процессору могут потребоваться дополнительные операции для чтения невыровненных данных.
